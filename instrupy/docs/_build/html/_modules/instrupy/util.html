

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>instrupy.util &mdash; InstruPy 0.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> InstruPy
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../instrument_models.html">Instrument Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../miscellaneous.html">Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">Use Cases</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">InstruPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>instrupy.util</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for instrupy.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">.. module:: util</span>

<span class="sd">:synopsis: *Utility classes and functions for the :class:`instrupy` package.*</span>

<span class="sd">This module contains the common classes and functions used by the instrument models. </span>
<span class="sd">The ``Orientation``, ``SphericalGeometry``, ``ViewGeometry``, ``Maneuver``, ``Antenna`` and ``SyntheticDataConfiguration`` classes are</span>
<span class="sd">purposed for handling common instrument parameters</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span> 
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">metpy.interpolate</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span> <span class="nn">lowtran</span>

<div class="viewcode-block" id="Entity"><a class="viewcode-back" href="../../generated/instrupy.util.Entity.html#instrupy.util.Entity">[docs]</a><span class="k">class</span> <span class="nc">Entity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An entity is an abstract class to aggregate common functionality.</span>
<span class="sd">    </span>
<span class="sd">    :ivar _id: Unique identifier for this entity.</span>
<span class="sd">    :vartype _id: str</span>
<span class="sd">    </span>
<span class="sd">    :ivar _type: Class type description for this entity.</span>
<span class="sd">    :vartype _type: str</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_type</span><span class="o">=</span><span class="s2">&quot;Entity&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an entity.</span>

<span class="sd">        :param _id: (default: None)</span>
<span class="sd">        :paramtype _id: str </span>

<span class="sd">        :param _type: (default: &quot;Entity&quot;)</span>
<span class="sd">        :paramtype _type: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">_type</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert this entity to a JSON-formatted dictionary.&quot;&quot;&quot;</span>
        <span class="c1"># extract and copy the python dictionary</span>
        <span class="n">json_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">recursive_normalize</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper function to recursively remove null values and serialize</span>
<span class="sd">            unserializable objects from dictionary.&quot;&quot;&quot;</span>
            <span class="c1"># if not a dictionary, return immediately</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Entity</span><span class="p">):</span> <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">d</span>
            <span class="c1"># otherwise loop through each key/value pair</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="c1"># if value is None remove key</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="c1"># else if non-seralizable object, manually serialize to json</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Entity</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="c1"># else if list, recursively serialize each list element</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">recursive_normalize</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="c1"># otherwise recursively call function</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">recursive_normalize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="n">recursive_normalize</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="c1"># translate special python to json keys: _id to @id, _type to @type</span>
        <span class="k">if</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">):</span> <span class="n">json_dict</span><span class="p">[</span><span class="s2">&quot;@id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_type&quot;</span><span class="p">):</span> <span class="n">json_dict</span><span class="p">[</span><span class="s2">&quot;@type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_type&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">json_dict</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serializes this entity to a JSON-formatted string or file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># return json string</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># write json file</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_doc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses an entity from a JSON-formatted string, dictionary, or file.&quot;&quot;&quot;</span>
        <span class="c1"># convert json string or file to dictionary (if necessary)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">json_doc</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_doc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="s1">&#39;read&#39;</span><span class="p">):</span>
            <span class="n">json_doc</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_doc</span><span class="p">)</span>
        <span class="c1"># if pre-formatted, return directly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">json_doc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="n">Entity</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">json_doc</span>
        <span class="c1"># if list, recursively parse each element and return mapped list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">json_doc</span><span class="p">)</span>
        <span class="c1"># otherwise use class method to initialize from normalized dictionary</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">json_doc</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses an entity from a normalized JSON dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Entity</span><span class="p">(</span><span class="n">_id</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overrides the default check if this entity is equal to another by</span>
<span class="sd">        comparing unique identifiers if available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if specified, perform comparison on unique identifier</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_id</span>
        <span class="c1"># otherwise return the default comparison using `is` operator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overrides the default check if this entity is not equal to another</span>
<span class="sd">        by comparing unique identifiers if available. (n.b. required for Python 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overrides the default hash function by using the unique identifiers</span>
<span class="sd">        if available.&quot;&quot;&quot;</span>
        <span class="c1"># if specified, return the hash of the unique identifier</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="c1"># otherwise return default hash from superclass</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Entity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span></div>

<div class="viewcode-block" id="EnumEntity"><a class="viewcode-back" href="../../generated/instrupy.util.EnumEntity.html#instrupy.util.EnumEntity">[docs]</a><span class="k">class</span> <span class="nc">EnumEntity</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration of recognized types.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attempts to parse a type from a string, otherwise returns None.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Constants"><a class="viewcode-back" href="../../generated/instrupy.util.Constants.html#instrupy.util.Constants">[docs]</a><span class="k">class</span> <span class="nc">Constants</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Collection of various frequently utilized constants. Unless indicated otherwise, the constants </span>
<span class="sd">        are in S.I. units. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radiusOfEarthInKM</span> <span class="o">=</span> <span class="mf">6378.137</span> <span class="c1"># [km] Nominal equatorial radius of Earth</span>
    <span class="n">speedOfLight</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">speed_of_light</span><span class="c1"># [meters per second]</span>
    <span class="n">GMe</span> <span class="o">=</span> <span class="mf">3.986004418e14</span><span class="o">*</span><span class="mf">1e-9</span> <span class="c1"># [km^3 s^-2] product of Gravitational constant and Mass of Earth </span>
    <span class="n">Boltzmann</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;Boltzmann constant&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">angularSpeedOfEarthInRadPerSec</span> <span class="o">=</span> <span class="mf">7292115e-11</span> <span class="c1"># [rad per sec] WGS-84 nominal mean angular velocity of Earth</span>
    <span class="n">Planck</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;Planck constant&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">SunBlackBodyTemperature</span> <span class="o">=</span> <span class="mf">6000.0</span> <span class="c1"># [Kelvin] Sun black body temperature</span>
    <span class="n">SolarRadius</span> <span class="o">=</span> <span class="mf">6.95700e8</span> <span class="c1"># [meters] Solar radius</span></div>

<div class="viewcode-block" id="SyntheticDataConfiguration"><a class="viewcode-back" href="../../generated/instrupy.util.SyntheticDataConfiguration.html#instrupy.util.SyntheticDataConfiguration">[docs]</a><span class="k">class</span> <span class="nc">SyntheticDataConfiguration</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class to handle configuration of synthetic data.</span>

<span class="sd">    :ivar sourceFilePaths: List of filepaths of the science-data files in NetCDF format. Each file corresponds to a specific (forecast/analysis) time.</span>
<span class="sd">    :vartype sourceFilePaths: list, str</span>

<span class="sd">    :ivar geophysicalVar: Geophysical variable (name as present in the source NetCDF file) to be used for the synthetic data.</span>
<span class="sd">    :vartype geophysicalVar: str</span>

<span class="sd">    :ivar interpolMethod: Interpolation method to be employed while spatially interpolating the source data onto the pixel-positions.</span>
<span class="sd">    :vartype interpolMethod: :class:`instrupy.util.SyntheticDataConfiguration.InterpolationMethod`</span>

<span class="sd">    :ivar _id: Unique identifier.</span>
<span class="sd">    :vartype _id: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">InterpolationMethod</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Enumeration of recognized interpolation methods which can be used for synthetic data production.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SCIPY_LINEAR</span> <span class="o">=</span> <span class="s2">&quot;SCIPY_LINEAR&quot;</span>
        <span class="n">METPY_LINEAR</span> <span class="o">=</span> <span class="s2">&quot;METPY_LINEAR&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sourceFilePaths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geophysicalVar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolMethod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceFilePaths</span> <span class="o">=</span> <span class="n">sourceFilePaths</span> <span class="k">if</span> <span class="n">sourceFilePaths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceFilePaths</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sourceFilePaths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceFilePaths</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geophysicalVar</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">geophysicalVar</span><span class="p">)</span> <span class="k">if</span> <span class="n">geophysicalVar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolMethod</span> <span class="o">=</span> <span class="n">SyntheticDataConfiguration</span><span class="o">.</span><span class="n">InterpolationMethod</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">interpolMethod</span><span class="p">)</span> <span class="k">if</span> <span class="n">interpolMethod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interpolators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;SCIPY_LINEAR&quot;</span><span class="p">:</span> <span class="n">SyntheticDataInterpolator</span><span class="o">.</span><span class="n">scipy_linear</span><span class="p">,</span> <span class="s2">&quot;METPY_LINEAR&quot;</span><span class="p">:</span> <span class="n">SyntheticDataInterpolator</span><span class="o">.</span><span class="n">metpy_linear</span><span class="p">}</span> <span class="c1"># list of available interpolators</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SyntheticDataConfiguration</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;SyntheticDataConfiguration&quot;</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Construct an ``SyntheticDataConfiguration`` object from a dictionary.</span>

<span class="sd">        :param d: Dictionary containing the synthetic data config specifications.</span>
<span class="sd">        :paramtype d: dict</span>
<span class="sd">    </span>
<span class="sd">        :return: ``SyntheticDataConfiguration`` object initialized with the input specifications.</span>
<span class="sd">        :rtype: :class:`instrupy.util.SyntheticDataConfiguration`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SyntheticDataConfiguration</span><span class="p">(</span><span class="n">sourceFilePaths</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sourceFilePaths&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> 
                                           <span class="n">geophysicalVar</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geophysicalVar&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                           <span class="n">interpolMethod</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;interpolMethod&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                                      <span class="n">_id</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the ``SyntheticDataConfiguration`` object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``SyntheticDataConfiguration`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">syndataconf_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sourceFilePaths&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFilePaths</span><span class="p">,</span> 
                            <span class="s2">&quot;geophysicalVar&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">geophysicalVar</span><span class="p">,</span> 
                            <span class="s2">&quot;interpolMethod&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolMethod</span><span class="p">,</span>
                            <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
                           <span class="p">}</span>
        <span class="k">return</span> <span class="n">syndataconf_dict</span>
    
    <span class="k">def</span> <span class="nf">get_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the interpolator associated with the configured interpolation method.</span>

<span class="sd">        :return: Interpolation function.</span>
<span class="sd">        :rtype: function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolMethod</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">interp</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> interpolation method was not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolMethod</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolMethod</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span>
    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SyntheticDataConfiguration.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Equality test is simple one which compares the data attributes.</span>
        <span class="c1"># note that _id data attribute may be different</span>
        <span class="c1"># @TODO: Make the list of strings comparison (sourceFilePaths variable) insensitive to order of the elements in the list and the case (upper/ lower cases).</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceFilePaths</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">sourceFilePaths</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geophysicalVar</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">geophysicalVar</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolMethod</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">interpolMethod</span><span class="p">)</span>         
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span></div>

<div class="viewcode-block" id="SyntheticDataInterpolator"><a class="viewcode-back" href="../../generated/instrupy.util.SyntheticDataInterpolator.html#instrupy.util.SyntheticDataInterpolator">[docs]</a><span class="k">class</span> <span class="nc">SyntheticDataInterpolator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class containting functional implementations of interpolators which shall be used to </span>
<span class="sd">        interpolate geophysical variable data onto pixel (center) positions to produce synthetic observations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">scipy_linear</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">var_data</span><span class="p">,</span> <span class="n">pixel_center_pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Execute SciPy linear interpolation on the input data.</span>

<span class="sd">        :param lons: (degrees) List of longitudes making the base grid. </span>
<span class="sd">        :paramtype lons: list, float</span>

<span class="sd">        :param lats: (degrees) List of latitudes making the base grid. </span>
<span class="sd">        :paramtype lons: list, float</span>

<span class="sd">        :param var_data: Geophysical variable data on the base grid.</span>
<span class="sd">        :paramtype var_data: list, float</span>

<span class="sd">        :param pixel_center_pos: Pixel center positions (locations to which the interpolation should take place).</span>
<span class="sd">                                 List of dictionaries with the dictionary keys as:</span>

<span class="sd">                                 1. lon[deg]: Longitude</span>
<span class="sd">                                 2. lat[deg]: Latitude</span>

<span class="sd">        :paramtype pixel_center_pos: list, dict</span>

<span class="sd">        :returns: Interpolated values at the pixel center positions.</span>
<span class="sd">        :rtype: list, float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp2d</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">var_data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="n">interpl_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_pix_p</span> <span class="ow">in</span> <span class="n">pixel_center_pos</span><span class="p">:</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">_pix_p</span><span class="p">[</span><span class="s1">&#39;lon[deg]&#39;</span><span class="p">]</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">_pix_p</span><span class="p">[</span><span class="s1">&#39;lat[deg]&#39;</span><span class="p">]</span>
            <span class="n">interpl_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># [0] is needed to convert from the single element np.array to float</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expect inaccuracy around longitude=0 deg&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interpl_data</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">metpy_linear</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">var_data</span><span class="p">,</span> <span class="n">pixel_center_pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Execute MetPy linear interpolation on the input data.</span>

<span class="sd">        :param lons: (degrees) List of longitudes making the base grid. </span>
<span class="sd">        :paramtype lons: list, float</span>

<span class="sd">        :param lats: (degrees) List of latitudes making the base grid. </span>
<span class="sd">        :paramtype lons: list, float</span>

<span class="sd">        :param var_data: Geophysical variable data on the base grid.</span>
<span class="sd">        :paramtype var_data: list, float</span>

<span class="sd">        :param pixel_center_pos: Pixel center positions (locations to which the interpolation should take place).</span>
<span class="sd">                                 List of dictionaries with the dictionary keys as:</span>

<span class="sd">                                 1. lon[deg]: Longitude</span>
<span class="sd">                                 2. lat[deg]: Latitude</span>

<span class="sd">        :paramtype pixel_center_pos: list, dict</span>

<span class="sd">        :returns: Interpolated values at the pixel center positions.</span>
<span class="sd">        :rtype: list, float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># transform input data into format required by the MetPy API</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">),))</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">),))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">var_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">var_data</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">pix_cen_pos</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pixel_center_pos</span><span class="p">:</span>
            <span class="n">pix_cen_pos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;lon[deg]&quot;</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;lat[deg]&quot;</span><span class="p">]])</span>
               
        <span class="n">interpl_data</span> <span class="o">=</span> <span class="n">metpy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interpolate_to_points</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">var_data</span><span class="p">,</span> <span class="n">pix_cen_pos</span><span class="p">,</span> <span class="n">interp_type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
                      <span class="c1"># metpy.interpolate.interpolate_to_points(coords, var_data, pixel_center_pos, interp_type=&#39;linear&#39;, </span>
                      <span class="c1">#                                          minimum_neighbors=3, gamma=0.25, kappa_star=5.052, </span>
                      <span class="c1">#                                          search_radius=None, rbf_func=&#39;linear&#39;, rbf_smooth=0)</span>
        <span class="k">return</span> <span class="n">interpl_data</span></div>

<span class="k">class</span> <span class="nc">ReferenceFrame</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Enumeration of recognized reference frames.</span>
<span class="sd">    </span>
<span class="sd">        :cvar EARTH_CENTERED_INERTIAL: Earth Centered Inertial reference frame.</span>
<span class="sd">        </span>
<span class="sd">                                        This is an Earth equator inertial reference frame identical to EarthMJ2000Eq coordinate system used in GMAT.</span>
<span class="sd">                                        The nominal x-axis points along the line formed by the intersection of the Earthâ€™s </span>
<span class="sd">                                        mean equatorial plane and the mean ecliptic plane (at the J2000 epoch), in the direction</span>
<span class="sd">                                        of Aries. The z-axis is normal to the Earthâ€™s mean equator at the J2000 epoch and the </span>
<span class="sd">                                        y-axis completes the right-handed system. The mean planes of the ecliptic and equator, </span>
<span class="sd">                                        at the J2000 epoch, are computed using IAU-1976/FK5 theory with 1980 update for nutation.</span>

<span class="sd">        :vartype EARTH_CENTERED_INERTIAL: str</span>

<span class="sd">        :cvar EARTH_FIXED: Earth Fixed reference frame.</span>

<span class="sd">                            The Earth Fixed reference frame is referenced to the Earth&#39;s equator and the prime meridian </span>
<span class="sd">                            and is computed using IAU-1976/FK5 theory. This system is identical to the EarthFixed coordinate</span>
<span class="sd">                            system used in GMAT.</span>

<span class="sd">        :vartype EARTH_FIXED: str</span>

<span class="sd">        :cvar NADIR_POINTING: Nadir-pointing reference frame.</span>

<span class="sd">                            The axis of the Nadir-pointing reference frame are defined as follows:</span>

<span class="sd">                            * :math:`\\bf X_{np}` axis: :math:`-({\\bf Z_{np}} \\times {\\bf V})`, where :math:`\\bf V` is the Velocity vector of satellite in EARTH_FIXED frame)</span>
<span class="sd">                                    </span>
<span class="sd">                            * :math:`\\bf Y_{np}` axis: :math:`({\\bf Z_{np}} \\times {\\bf X_{np}})`</span>
<span class="sd">                                    </span>
<span class="sd">                            * :math:`\\bf Z_{np}` axis: Aligned to Nadir vector (i.e. the negative of the position vector of satellite in EARTH_FIXED frame)</span>

<span class="sd">                            .. todo:: Verify the claim about position vector and velocity vector in EARTH_FIXED frame.</span>

<span class="sd">        :vartype NADIR_POINTING: str</span>

<span class="sd">        :cvar SC_BODY_FIXED: Spacecraft Body Fixed reference frame. The axis of this coordinate system is fixed to the Spacecraft Bus. </span>
<span class="sd">        :vartype SC_BODY_FIXED: str</span>

<span class="sd">        :cvar SENSOR_BODY_FIXED: Sensor Body Fixed reference frame. The axis of this coordinate system is fixed to the Sensor. </span>
<span class="sd">        :vartype SENSOR_BODY_FIXED: str</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EARTH_CENTERED_INERTIAL</span> <span class="o">=</span> <span class="s2">&quot;EARTH_CENTERED_INERTIAL&quot;</span>
    <span class="n">EARTH_FIXED</span> <span class="o">=</span> <span class="s2">&quot;EARTH_FIXED&quot;</span>
    <span class="n">NADIR_POINTING</span> <span class="o">=</span> <span class="s2">&quot;NADIR_POINTING&quot;</span>
    <span class="n">SC_BODY_FIXED</span> <span class="o">=</span> <span class="s2">&quot;SC_BODY_FIXED&quot;</span>
    <span class="n">SENSOR_BODY_FIXED</span> <span class="o">=</span> <span class="s2">&quot;SENSOR_BODY_FIXED&quot;</span>

<div class="viewcode-block" id="Orientation"><a class="viewcode-back" href="../../generated/instrupy.util.Orientation.html#instrupy.util.Orientation">[docs]</a><span class="k">class</span> <span class="nc">Orientation</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class to store and handle orientation. Orientation is parameterized as intrinsic rotations specified by Euler angles and sequence </span>
<span class="sd">        with respect to the user-specified reference frame. The definition of the Euler angle rotation is identical to the </span>
<span class="sd">        one used in the orbitpy-&gt;propcov-&gt;extern-&gt;gmatutil-&gt;util-&gt;AttitudeUtil, AttitudeConversionUtility C++ classes.</span>

<span class="sd">        A Euler sequence = 123 implies the following rotation: R = R3.R2.R1, where Ri is the rotation matrix about the ith axis. </span>
<span class="sd">        A positive angle corresponds to an anti-clockwise rotation about the respective axis.</span>
<span class="sd">        Each rotation matrix rotates the coordinate system (not the vector). </span>
<span class="sd">        See:</span>
<span class="sd"> </span>
<span class="sd">         * https://mathworld.wolfram.com/RotationMatrix.html</span>
<span class="sd">     </span>
<span class="sd">        :ivar ref_frame: Reference frame. Default in &quot;NADIR_POINTING&quot;.</span>
<span class="sd">        :vartype ref_frame: str</span>

<span class="sd">        :ivar euler_angle1: (deg) Rotation angle corresponding to the first rotation. Default is 0.</span>
<span class="sd">        :vartype euler_angle1: float</span>

<span class="sd">        :ivar euler_angle2: (deg) Rotation angle corresponding to the second rotation. Default is 0.</span>
<span class="sd">        :vartype euler_angle2: float</span>

<span class="sd">        :ivar euler_angle3: (deg) Rotation angle corresponding to the third rotation. Default is 0.</span>
<span class="sd">        :vartype euler_angle3: float</span>

<span class="sd">        :ivar euler_seq1: Axis-number corresponding to the first rotation. Default is 1.</span>
<span class="sd">        :vartype euler_angle1: int</span>

<span class="sd">        :ivar euler_seq2: Axis-number corresponding to the second rotation. Default is 2.</span>
<span class="sd">        :vartype euler_angle2: int</span>

<span class="sd">        :ivar euler_seq3: Axis-number corresponding to the third rotation. Default is 3.</span>
<span class="sd">        :vartype euler_angle3: int</span>

<span class="sd">        :ivar _id: Unique identifier.</span>
<span class="sd">        :vartype _id: str</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">,</span> <span class="n">euler_angle1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">euler_angle2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">euler_angle3</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">euler_seq1</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">euler_seq2</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">euler_seq3</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ref_frame</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">euler_angle1</span><span class="p">)</span><span class="o">%</span><span class="mi">360</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">euler_angle2</span><span class="p">)</span><span class="o">%</span><span class="mi">360</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle3</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">euler_angle3</span><span class="p">)</span><span class="o">%</span><span class="mi">360</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq1</span> <span class="o">=</span> <span class="n">euler_seq1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq2</span> <span class="o">=</span> <span class="n">euler_seq2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq3</span> <span class="o">=</span> <span class="n">euler_seq3</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Orientation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;Orientation&quot;</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    def get_pointing_vector_angle_wrt_input_vector(self, vec):</span>
<span class="sd">        &quot;&quot;&quot; Get the angle between the pointing-vector and an input vector. This function may be applied to calculate the off-nadir angle of the</span>
<span class="sd">            instrument pointing. The pointing axis is assumed to be aligned along the z-axis SENSOR_BODY_FIXED frame.</span>

<span class="sd">        :param vec: Input vector.</span>
<span class="sd">        :paramtype vec: array_like, shape (3, 1), float</span>

<span class="sd">        :return: Angle between the pointing vector and the input vector</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        pointing_axis_sensor_frame = np.array([0,0,1]) # assumed pointing axis in the SENSOR_BODY_FIXED frame</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_rotation_matrix</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">angle_deg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the rotation matrix corresponding to an input rotation axis (x or y or z) and rotation angle.</span>
<span class="sd">        TODO: Write unittest for this function.</span>

<span class="sd">        :param axis: Rotation axis index. Must be 1 or 2 or 3.</span>
<span class="sd">        :paramtype axis: int</span>

<span class="sd">        :param angle_deg: Rotation angle in degrees.</span>
<span class="sd">        :paramtype angle_deg: float</span>

<span class="sd">        :return: 3x3 rotation matrix.</span>
<span class="sd">        :rtype: np.array, shape (3,3), float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle_deg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)],</span>
                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)]</span>
                            <span class="p">])</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>   <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)],</span>
                             <span class="p">[</span>            <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>              <span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>  <span class="mi">0</span><span class="p">,</span>   <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)]</span>
                            <span class="p">])</span>        
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>   <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>  <span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>   <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>  <span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span>              <span class="mi">0</span><span class="p">,</span>              <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>
                            <span class="p">])</span>
    

    <span class="k">class</span> <span class="nc">Convention</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Enumeration of recognized orientation conventions with which an object can be initialized. The rotations below can be specified with respect to </span>
<span class="sd">            any of the reference frames given in :class:`instrupy.util.ReferenceFrame`.</span>

<span class="sd">        :cvar XYZ: Rotations about the X, Y and Z axis in the order 123.</span>
<span class="sd">        :vartype XYZ: str</span>

<span class="sd">        :cvar REF_FRAME_ALIGNED: Aligned with respective to the underlying reference frame. Identity rotation matrix. </span>
<span class="sd">        :vartype REF_FRAME_ALIGNED: str</span>

<span class="sd">        :cvar SIDE_LOOK: Rotation about the Y axis only. </span>
<span class="sd">        :vartype SIDE_LOOK: str</span>

<span class="sd">        :cvar EULER: Rotation according to the specified Euler angles and sequence.</span>
<span class="sd">        :vartype EULER: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">XYZ</span> <span class="o">=</span> <span class="s2">&quot;XYZ&quot;</span>
        <span class="n">REF_FRAME_ALIGNED</span> <span class="o">=</span> <span class="s2">&quot;REF_FRAME_ALIGNED&quot;</span>
        <span class="n">SIDE_LOOK</span> <span class="o">=</span> <span class="s2">&quot;SIDE_LOOK&quot;</span>
        <span class="n">EULER</span> <span class="o">=</span> <span class="s2">&quot;EULER&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_sideLookAngle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return :class:`Orientation` object constructed from the side-look angle. </span>
<span class="sd">        </span>
<span class="sd">        :param ref_frame: Reference frame. Default in &quot;NADIR_POINTING&quot;.</span>
<span class="sd">        :paramtype ref_frame: str</span>

<span class="sd">        :param side_look_angle: (deg) Side look angle. A positive angle corresponds to anti-clockwise rotation applied around the y-axis. Default is 0.</span>
<span class="sd">        :paramtype side_look_angle: float</span>

<span class="sd">        :param _id: Unique identifier.</span>
<span class="sd">        :paramtype _id: str</span>

<span class="sd">        :return: Corresponding ``Orientation`` object.</span>
<span class="sd">        :rtype: :class:`instrupy.util.Orientation`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">ref_frame</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">_id</span><span class="p">)</span>
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_XYZ_rotations</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">,</span> <span class="n">x_rot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_rot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_rot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return :class:`Orientation` object constructed from the user-specified XYZ rotation angles with  </span>
<span class="sd">            the sequence=123.</span>

<span class="sd">        :param ref_frame: Reference frame. Default in &quot;NADIR_POINTING&quot;.</span>
<span class="sd">        :paramtype ref_frame: str</span>

<span class="sd">        :ivar x_rot: (deg) Rotation about X-axis. Default is 0.</span>
<span class="sd">        :vartype x_rot: float</span>

<span class="sd">        :ivar y_rot: (deg) Rotation about Y-axis. Default is 0.</span>
<span class="sd">        :vartype y_rot: float</span>

<span class="sd">        :ivar z_rot: (deg) Rotation about Z-axis. Default is 0.</span>
<span class="sd">        :vartype z_rot: float`</span>

<span class="sd">        :param _id: Unique identifier.</span>
<span class="sd">        :paramtype _id: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">ref_frame</span><span class="p">,</span> <span class="n">x_rot</span><span class="p">,</span> <span class="n">y_rot</span><span class="p">,</span> <span class="n">z_rot</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">_id</span><span class="p">)</span>       
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses a ``Orientation`` object from the input dictionary.</span>
<span class="sd">        </span>
<span class="sd">            :param d: Dictionary containing the orientation specifications.</span>
<span class="sd">            :paramtype d: dict</span>

<span class="sd">            :return: ``Orientation`` object initialized with the input specifications.</span>
<span class="sd">            :rtype: :class:`instrupy.util.Orientation`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orien_conv</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">Convention</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;convention&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;referenceFrame&quot;</span><span class="p">,</span> <span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">value</span> <span class="c1"># default reference frame is NADIR_POINTING</span>
        <span class="k">if</span><span class="p">(</span><span class="n">orien_conv</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_XYZ_rotations</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="n">ref_frame</span><span class="p">,</span> <span class="n">x_rot</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;xRotation&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y_rot</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;yRotation&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">z_rot</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zRotation&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">_id</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">orien_conv</span> <span class="o">==</span> <span class="s2">&quot;SIDE_LOOK&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_sideLookAngle</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="n">ref_frame</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sideLookAngle&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">_id</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">orien_conv</span> <span class="o">==</span> <span class="s2">&quot;REF_FRAME_ALIGNED&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_sideLookAngle</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="n">ref_frame</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">orien_conv</span> <span class="o">==</span> <span class="s2">&quot;EULER&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="n">ref_frame</span><span class="p">,</span> <span class="n">euler_angle1</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eulerAngle1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">euler_angle2</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eulerAngle2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
                               <span class="n">euler_angle3</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eulerAngle3&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">euler_seq1</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eulerSeq1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">euler_seq2</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eulerSeq2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                               <span class="n">euler_seq3</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eulerSeq3&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">_id</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid or no Orientation convention specification&quot;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># TODO: remove this function</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return data members of the instance as a tuple.</span>
<span class="sd">        </span>
<span class="sd">            :return: ``Orientation`` object data attributes as namedtuple.</span>
<span class="sd">            :rtype: namedtuple, (str, int, int, int, float, float, float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;orientation&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;ref_frame&quot;</span><span class="p">,</span> <span class="s2">&quot;euler_seq1&quot;</span><span class="p">,</span> <span class="s2">&quot;euler_seq2&quot;</span><span class="p">,</span> <span class="s2">&quot;euler_seq3&quot;</span><span class="p">,</span> <span class="s2">&quot;euler_angle1&quot;</span><span class="p">,</span> <span class="s2">&quot;euler_angle2&quot;</span><span class="p">,</span> <span class="s2">&quot;euler_angle3&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">orientation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the ``Orientation`` object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">            :return: ``Orientation`` object as python dictionary.</span>
<span class="sd">            :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orien_dict</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="s2">&quot;referenceFrame&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> 
                      <span class="s2">&quot;convention&quot;</span><span class="p">:</span> <span class="s2">&quot;EULER&quot;</span><span class="p">,</span> 
                      <span class="s2">&quot;eulerAngle1&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span>  
                      <span class="s2">&quot;eulerAngle2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> 
                      <span class="s2">&quot;eulerAngle3&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span>
                      <span class="s2">&quot;eulerSeq1&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> 
                      <span class="s2">&quot;eulerSeq2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> 
                      <span class="s2">&quot;eulerSeq3&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">,</span>
                      <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
                     <span class="p">}</span>
        <span class="k">return</span> <span class="n">orien_dict</span>
    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Orientation(ref_frame=&#39;</span><span class="si">{}</span><span class="s2">&#39;,euler_angle1=</span><span class="si">{}</span><span class="s2">,euler_angle2=</span><span class="si">{}</span><span class="s2">,euler_angle3=</span><span class="si">{}</span><span class="s2">,euler_seq1=</span><span class="si">{}</span><span class="s2">,euler_seq2=</span><span class="si">{}</span><span class="s2">,euler_seq3=</span><span class="si">{}</span><span class="s2">,_id=&#39;</span><span class="si">{}</span><span class="s2">&#39;)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span>
                                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Orientation(ref_frame=&#39;</span><span class="si">{}</span><span class="s2">&#39;,euler_angle1=</span><span class="si">{}</span><span class="s2">,euler_angle2=</span><span class="si">{}</span><span class="s2">,euler_angle3=</span><span class="si">{}</span><span class="s2">,euler_seq1=</span><span class="si">{}</span><span class="s2">,euler_seq2=</span><span class="si">{}</span><span class="s2">,euler_seq3=</span><span class="si">{}</span><span class="s2">,_id=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span>
                                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="c1"># Equality test is simple one which compares the data attributes. It does not cover complex cases where the data members may be unequal, but </span>
            <span class="c1"># the Orientation is physically the same.</span>
            <span class="c1"># note that _id data attribute may be different</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_angle1</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_angle2</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_angle3</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">)</span> \
                       <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_seq1</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_seq2</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_seq3</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>                    
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span></div>

<div class="viewcode-block" id="SphericalGeometry"><a class="viewcode-back" href="../../generated/instrupy.util.SphericalGeometry.html#instrupy.util.SphericalGeometry">[docs]</a><span class="k">class</span> <span class="nc">SphericalGeometry</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Class to handle spherical geometries (spherical polygons and circles) which define an closed angular space of interest.</span>
<span class="sd">            </span>
<span class="sd">            The spherical geometry is maintained internally via vector of cone and clock angles defined in the SENSOR_BODY_FIXED frame with </span>
<span class="sd">            the Z-axis as the pointing axis. This can be paired with an Orientation object (which describes the orientation of the sensor (hence the SENSOR_BODY_FIXED frame)</span>
<span class="sd">            with respect to a reference frame) to obtain the position of the spherical geometry in any desired reference frame.</span>
<span class="sd">       </span>
<span class="sd">        :ivar shape: Shape of the spherical geometry. Accepted values are &quot;CIRCULAR&quot;, &quot;RECTANGULAR&quot; or &quot;CUSTOM&quot;.</span>
<span class="sd">        :vartype shape: str</span>

<span class="sd">        :ivar cone_angle_vec: (deg) Array of cone angles measured from +Z sensor axis (pointing axis). If (:math:`xP`, :math:`yP`, :math:`zP`) is a unit vector describing a point on unit sphere, then the </span>
<span class="sd">                                 cone angle for the point is :math:`\\pi/2 - \\sin^{-1}zP`.</span>
<span class="sd">        :vartype cone_angle_vec: list, float</span>

<span class="sd">        :ivar clock_angle_vec: (deg) Array of clock angles (right ascensions) measured anti-clockwise from the +X-axis. If (:math:`xP`, :math:`yP`, :math:`zP`) is a unit vector</span>
<span class="sd">                                  describing a point on unit sphere, then the clock angle for the point is :math:`atan2(yP,xP)`.</span>
<span class="sd">        :vartype clock_angle_vec: list, float</span>

<span class="sd">        :ivar diameter: (deg) Spherical circular (about the sensor Z axis) diameter (only for CIRCULAR shape).</span>
<span class="sd">        :vartype diameter: float</span>

<span class="sd">        :ivar angle_height: (deg) Spherical rectangular geometry angular width (about sensor X axis) (only for *RECTANGULAR* shape). </span>
<span class="sd">                                    Corresponds to along-track angular width if sensor frame is aligned to *NADIR_POINTING* frame.</span>
<span class="sd">        :vartype angle_height: float</span>

<span class="sd">        :ivar angle_width: (deg) Spherical rectangular geometry angular height (about sensor Y axis)  (only for *RECTANGULAR* shape). </span>
<span class="sd">                                    Corresponds to cross-track angular width if sensor frame is aligned to *NADIR_POINTING* frame.</span>
<span class="sd">        :vartype angle_width: float</span>

<span class="sd">        :param _id: Unique identifier.</span>
<span class="sd">        :paramtype _id: str</span>

<span class="sd">        .. note:: :code:`cone_angle_vec[0]` ties to :code:`clock_angle_vec[0]` and so on. The last point in both the vectors should be the same as the first point to ensure FOV closure.</span>
<span class="sd">                  Except for the case of *CIRCULAR* shaped FOV, in which we have only one cone angle (:code:`cone_angle_vec[0] = 1/2 diameter`) and no corresponding clock angle. </span>
<span class="sd">            </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">Shape</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Enumeration of recognized SphericalGeometry shapes.</span>
<span class="sd">            </span>
<span class="sd">            :cvar CIRCULAR: Circular shape definition, characterized by the radius of the circle around the Z-axis.</span>
<span class="sd">            :vartype CIRCULAR: str</span>

<span class="sd">            :cvar RECTANGULAR: Rectangular spherical polygon definition, characterized by angular width (about Y-axis) and angular height (about X-axis). </span>
<span class="sd">            :vartype RECTANGULAR: str</span>

<span class="sd">            :cvar CUSTOM: Custom polygon definition, where an arbitrary number of cone, clock angles</span>
<span class="sd">                          denoting the vertices of the spherical polygon can be specified. </span>
<span class="sd">            :vartype CUSTOM: str</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">CIRCULAR</span> <span class="o">=</span> <span class="s2">&quot;CIRCULAR&quot;</span>
            <span class="n">RECTANGULAR</span> <span class="o">=</span> <span class="s2">&quot;RECTANGULAR&quot;</span>
            <span class="n">CUSTOM</span> <span class="o">=</span> <span class="s2">&quot;CUSTOM&quot;</span>
            
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cone_angle_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clock_angle_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>   
            <span class="k">if</span><span class="p">(</span><span class="n">cone_angle_vec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">cone_angle_vec</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">%</span><span class="mi">360</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span><span class="o">%</span><span class="mi">360</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">clock_angle_vec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">clock_angle_vec</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">%</span><span class="mi">360</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">)</span><span class="o">%</span><span class="mi">360</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_height</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_width</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span>

            <span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span><span class="p">):</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">get_rect_poly_specs_from_cone_clock_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span><span class="p">)</span>
                

            <span class="nb">super</span><span class="p">(</span><span class="n">SphericalGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;SphericalGeometry&quot;</span><span class="p">)</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Parses spherical geometry specifications from a normalized JSON dictionary.</span>
<span class="sd">    </span>
<span class="sd">               :param d: Dictionary with the spherical geometry specifications.</span>
<span class="sd">               :paramtype d: dict</span>

<span class="sd">               :return: Spherical geometry object</span>
<span class="sd">               :rtype: :class:`instrupy.util.SphericalGeometry`</span>

<span class="sd">            &quot;&quot;&quot;</span>          
            <span class="n">shape</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="k">if</span><span class="p">(</span><span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;CIRCULAR&quot;</span><span class="p">):</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_circular_specs</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;diameter&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;RECTANGULAR&quot;</span><span class="p">):</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_rectangular_specs</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;angleHeight&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;angleWidth&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;CUSTOM&quot;</span><span class="p">):</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_custom_specs</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;customConeAnglesVector&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;customClockAnglesVector&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>  
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid spherical geometry shape specified.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sph_geom_dict</span>

        <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Translate the ``SphericalGeometry`` object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>

<span class="sd">                :return: ``SphericalGeometry`` object as python dictionary.</span>
<span class="sd">                :rtype: dict </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">:</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;CIRCULAR&quot;</span><span class="p">,</span> <span class="s2">&quot;diameter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">,</span> <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">}</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span><span class="p">:</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;RECTANGULAR&quot;</span><span class="p">,</span> <span class="s2">&quot;angleHeight&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_height</span><span class="p">,</span> <span class="s2">&quot;angleWidth&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_width</span><span class="p">,</span> <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">}</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">:</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;CUSTOM&quot;</span><span class="p">,</span> 
                            <span class="s2">&quot;customConeAnglesVector&quot;</span><span class="p">:</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="p">))</span>  <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span> 
                            <span class="s2">&quot;customClockAnglesVector&quot;</span><span class="p">:</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span><span class="p">))</span>  <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
                           <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">sph_geom_dict</span>

        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="c1"># Equality test is simple one which compares the data attributes. It does not cover complex cases where the data members may be unequal, but </span>
            <span class="c1"># the spherical shape is physically the same.</span>
            <span class="c1"># note that _id data attribute may be different</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">diameter</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_width</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">angle_width</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_height</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">angle_height</span><span class="p">)</span> <span class="ow">and</span> \
                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">clock_angle_vec</span><span class="p">)</span>
                    
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>                    

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">from_custom_specs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cone_angle_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clock_angle_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;  Return corresponding :class:`instrupy.util.SphericalGeometry` object from input cone and clock angles.</span>

<span class="sd">                :param cone_angle_vec: (deg) Array of cone angles measured from +Z sensor axis. If (:math:`xP`, :math:`yP`, :math:`zP`) is a unit vector describing a point on unit sphere, then the </span>
<span class="sd">                                 cone angle for the point is :math:`\\pi/2 - \\sin^{-1}zP`.</span>
<span class="sd">                :paramtype cone_angle_vec: list, float</span>

<span class="sd">                :param clock_angle_vec: (deg) Array of clock angles (right ascensions) measured anti-clockwise from the + X-axis. If (:math:`xP`, :math:`yP`, :math:`zP`) is a unit vector</span>
<span class="sd">                                        describing a point on the unit sphere, then the clock angle for the point is :math:`atan2(yP,xP)`.</span>
<span class="sd">                :paramtype clock_angle_vec: list, float</span>

<span class="sd">                :param _id: Unique identifier.</span>
<span class="sd">                :paramtype _id: str</span>

<span class="sd">                :return: Corresponding ``SphericalGeometry`` object</span>
<span class="sd">                :rtype: :class:`instrupy.util.SphericalGeometry`</span>

<span class="sd">                .. note:: :code:`cone_angle_vec[0]` ties to :code:`clock_angle_vec[0]` and so on. The last point in both the vectors should be the same as the first point to ensure FOV closure.</span>
<span class="sd">                          Except for the case of *CIRCULAR* shaped FOV, in which we have only one cone angle (:code:`cone_angle_vec[0] = 1/2 diameter`) and no corresponding clock angle.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">cone_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">cone_angle_vec</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No cone angle vector specified!&quot;</span><span class="p">)</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">clock_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_angle_vec</span><span class="p">]</span>

            <span class="k">if</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;CUSTOM cone angles specification must be in the range 0 deg to 90 deg.&quot;</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">clock_angle_vec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;With only one cone angle specified, there should be no clock angles specified.&quot;</span><span class="p">)</span>
                
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">clock_angle_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))):</span> <span class="c1"># i.e. check that this is a specification with list of vertices of the spherical polygon</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;With more than one cone angle specified, the length of cone angle vector should be the same as length of the clock angle vector.&quot;</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">4</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;For a spherical polygon specification with list of vertices, there should be atleast 4 vertices with the last vertex same as the first vertex.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">cone_angle_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;For a spherical polygon specification with list of vertices, the last vertex should be the same as the first vertex.&quot;</span><span class="p">)</span>
                
            <span class="k">return</span> <span class="n">SphericalGeometry</span><span class="p">(</span><span class="s2">&quot;CUSTOM&quot;</span><span class="p">,</span> <span class="n">cone_angle_vec</span><span class="p">,</span> <span class="n">clock_angle_vec</span><span class="p">,</span> <span class="n">_id</span><span class="p">)</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">from_circular_specs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Convert input circular specs to cone, clock angles and return corresponding :class:`instrupy.util.SphericalGeometry` object.</span>
<span class="sd">            </span>
<span class="sd">            :param diameter: (deg) Diameter of the circle.</span>
<span class="sd">            :paramtype diameter: float</span>

<span class="sd">            :param _id: Unique identifier</span>
<span class="sd">            :paramtype _id: str</span>

<span class="sd">            :return: Corresponding ``SphericalGeometry`` object</span>
<span class="sd">            :rtype: :class:`instrupy.util.SphericalGeometry`</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">diameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please specify diameter of the CIRCULAR fov.&quot;</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">diameter</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">diameter</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Specified diameter of CIRCULAR fov must be within the range 0 deg to 180 deg&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">SphericalGeometry</span><span class="p">(</span><span class="s2">&quot;CIRCULAR&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">diameter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="p">)</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">from_rectangular_specs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angle_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Convert the angle_height and angle_width rectangular specs to clock, cone angles and return corresponding :class:`instrupy.util.SphericalGeometry` object.</span>

<span class="sd">            :param angle_height: (deg) Angular height (about sensor X axis). Corresponds to along-track FOV if sensor is aligned to *NADIR_POINTING* frame.</span>
<span class="sd">            :paramtype angle_height: float</span>

<span class="sd">            :param angle_width: (deg) Angular width (about sensor Y axis). Corresponds to cross-track FOV if sensor is aligned to *NADIR_POINTING* frame.</span>
<span class="sd">            :paramtype angle_width: float</span>
<span class="sd">            </span>
<span class="sd">            :param _id: Unique identifier</span>
<span class="sd">            :paramtype _id: str</span>

<span class="sd">            :return: Corresponding ``SphericalGeometry`` object</span>
<span class="sd">            :rtype: :class:`instrupy.util.SphericalGeometry`                      </span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">angle_height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">angle_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please specify the angle_height and angle_width for the RECTANGULAR fov.&quot;</span><span class="p">)</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">angle_height</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle_height</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="ow">or</span> <span class="n">angle_width</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle_width</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Specified angle_height and angle_width of the RECTANGULAR fov must be within the range 0 deg to 180 deg&quot;</span><span class="p">)</span>       
            
            <span class="n">angle_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle_height</span><span class="p">)</span>
            <span class="n">angle_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle_width</span><span class="p">)</span>

            <span class="n">cosCone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_height</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="n">cone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosCone</span><span class="p">)</span>

            <span class="n">sinClock</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_height</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">cone</span><span class="p">)</span>

            <span class="n">clock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">sinClock</span><span class="p">)</span>

            <span class="n">cone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">cone</span><span class="p">)</span>
            <span class="n">clock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span>

            <span class="n">cone_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">cone</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">cone</span><span class="p">]</span>

            <span class="n">clock_angle_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock</span><span class="p">,</span> <span class="mf">180.0</span><span class="o">-</span><span class="n">clock</span><span class="p">,</span> <span class="mf">180.0</span><span class="o">+</span><span class="n">clock</span><span class="p">,</span> <span class="o">-</span><span class="n">clock</span><span class="p">,</span> <span class="n">clock</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">SphericalGeometry</span><span class="p">(</span><span class="s2">&quot;RECTANGULAR&quot;</span><span class="p">,</span> <span class="n">cone_angle_vec</span><span class="p">,</span> <span class="n">clock_angle_vec</span><span class="p">,</span> <span class="n">_id</span><span class="p">)</span>        
        
        <span class="k">def</span> <span class="nf">get_cone_clock_fov_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Function to the get the cone and clock angle vectors from the respective ``SphericalGeometry`` object.</span>

<span class="sd">                :return: Cone, Clock angles in degrees</span>
<span class="sd">                :rtype: list, float</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cone_angle_vec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock_angle_vec</span><span class="p">]</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">get_rect_poly_specs_from_cone_clock_angles</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">,</span> <span class="n">clock_angle_vec</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Function to get the rectangular specifications (angle_height and angle_width), from input clock, cone angle vectors.           </span>

<span class="sd">                :param cone_angle_vec: (deg) Array of cone angles measured from +Z sensor axis. If (:math:`xP`, :math:`yP`, :math:`zP`) is a unit vector describing a point on unit sphere, then the </span>
<span class="sd">                                 cone angle for the point is :math:`\\pi/2 - \\sin^{-1}zP`. </span>
<span class="sd">                :paramtype cone_angle_vec: list, float</span>

<span class="sd">                :param clock_angle_vec: (deg) Array of clock angles (right ascensions) measured anti-clockwise from the + X-axis. If (:math:`xP`, :math:`yP`, :math:`zP`) is a unit vector</span>
<span class="sd">                                        describing a point on unit sphere, then the clock angle for the point is :math:`atan2(yP,xP)`.</span>
<span class="sd">                :paramtype clock_angle_vec: list, float</span>

<span class="sd">                :return: angle_height and angle_width in degrees</span>
<span class="sd">                :rtype: list, float</span>
<span class="sd">      </span>
<span class="sd">                .. todo:: Make sure selected clock angle is from first quadrant. </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Check if the instance does correspond to an rectangular shape.</span>

            <span class="c1"># Length of cone angle vector and clock angle vector must be 5, with the last point same as the first point.</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This SphericalGeometry instance does not correspond to a rectangular shape.&quot;</span><span class="p">)</span>
            <span class="c1"># Check that all elements in the cone angle vector are the same value.</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">))</span><span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This SphericalGeometry instance does not correspond to a rectangular shape.&quot;</span><span class="p">)</span>
            <span class="c1"># The elements of the clock angle vector satisfy the following relationship: [theta, 180-theta, 180+theta, 360-theta, theta]</span>
            <span class="c1"># in case of rectangular shape. Check for this relationship.</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">],(</span><span class="mi">360</span><span class="o">-</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">180</span> <span class="o">-</span> <span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="mi">180</span> <span class="o">+</span> <span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This SphericalGeometry instance does not correspond to a rectangular shape.&quot;</span><span class="p">)</span> 
            
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">cone_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">clock_angle_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">))</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>

            <span class="n">angle_height</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">angle_width</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">angle_height</span><span class="p">,</span> <span class="n">angle_width</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_fov_height_and_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Get the angle_height and angle_width. Valid only for *CIRCULAR* and *RECTANGULAR* shapes.</span>

<span class="sd">                :return: angle_height and angle_width in degrees</span>
<span class="sd">                :rtype: list, float</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_width</span><span class="p">]</span>

        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;SphericalGeometry.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span></div>

<div class="viewcode-block" id="ViewGeometry"><a class="viewcode-back" href="../../generated/instrupy.util.ViewGeometry.html#instrupy.util.ViewGeometry">[docs]</a><span class="k">class</span> <span class="nc">ViewGeometry</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Container class which congregates the :class:`SphericalGeometry` and :class:`Orientation` objects and can be used to model</span>
<span class="sd">        the Field of View (FOV) or Scene FOV or Field of Regard (FOR) of a sensor. </span>

<span class="sd">        The :code:`SphericalGeometry` member of the container describes the spherical geometry (polygon/ circle) in the SENSOR_BODY_FIXED frame</span>
<span class="sd">        with the Z-axis as the pointing axis. This can be paired with an Orientation object (which describes the orientation of the sensor (hence the SENSOR_BODY_FIXED frame)</span>
<span class="sd">        with respect to a reference frame) to obtain the position of the spherical geometry in any desired reference frame.</span>
<span class="sd">        </span>
<span class="sd">        In the current :class:`instrupy` implementation when used to model the FOR, the Orientation is always defined with respect to the </span>
<span class="sd">        *NADIR_POINTING* reference frame. </span>

<span class="sd">    :ivar orien: Orientation of the sensor (and hence &quot;orientation&quot; of the spherical geometry which is described in the *SENSOR_BODY_FIXED* frame).</span>
<span class="sd">    :vartype orien: :class:`instrupy.util.Orientation`</span>
<span class="sd">    </span>
<span class="sd">    :ivar sph_geom: Spherical geometry object associated with the FOV/ Scene FOV/ FOR.</span>
<span class="sd">    :vartype sph_geom: :class:`instrupy.util.SphericalGeometry`</span>

<span class="sd">    :param _id: Unique identifier.</span>
<span class="sd">    :paramtype _id: str</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orien</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sph_geom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orien</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">orien</span><span class="p">)</span> <span class="k">if</span> <span class="n">orien</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orien</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sph_geom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sph_geom</span><span class="p">)</span> <span class="k">if</span> <span class="n">sph_geom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sph_geom</span><span class="p">,</span> <span class="n">SphericalGeometry</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ViewGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;ViewGeometry&quot;</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Parses an ``ViewGeometry`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the viewing-geometry specifications.</span>

<span class="sd">                Following keys are to be specified.</span>
<span class="sd">                </span>
<span class="sd">                * &quot;orientation&quot;:            (dict) Refer to :class:`instrupy.util.Orientation.from_dict`</span>
<span class="sd">                * &quot;sphericalGeometry&quot;:      (dict) Refer to :class:`instrupy.util.SphericalGeometry.from_dict`</span>
<span class="sd">                * &quot;@id&quot;:                    (str or int) Unique identifier of the ``ViewGeometry`` object.</span>

<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``ViewGeometry`` object.</span>
<span class="sd">        :rtype: :class:`instrupy.util.ViewGeometry`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orien_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">sph_geom_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sphericalGeometry&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ViewGeometry</span><span class="p">(</span><span class="n">orien</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">orien_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">orien_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">sph_geom</span> <span class="o">=</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">sph_geom_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">sph_geom_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">_id</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;@id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Equality test is simple one which compares the data attributes.</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orien</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">orien</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sph_geom</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">sph_geom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the ``ViewGeometry`` object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>

<span class="sd">        :return: ``ViewGeometry`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;orientation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">orien</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="s2">&quot;sphericalGeometry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sph_geom</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#orien_dict = self.orien.to_dict() if self.orien is not None and isinstance(self.orien, Orientation) else None</span>
        <span class="c1">#sph_geom_dict = self.sph_geom.to_dict() if self.sph_geom is not None and isinstance(self.sph_geom, SphericalGeometry) else None</span>
        <span class="c1">#return &quot;ViewGeometry(orien=Orientation.from_dict({}), sph_geom=SphericalGeometry.from_dict({}))&quot;.format(orien_dict, sph_geom_dict)</span>
        <span class="k">return</span> <span class="s2">&quot;ViewGeometry.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span></div>

<div class="viewcode-block" id="Maneuver"><a class="viewcode-back" href="../../generated/instrupy.util.Maneuver.html#instrupy.util.Maneuver">[docs]</a><span class="k">class</span> <span class="nc">Maneuver</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class handling the maneuverability of the satellite-sensor system. </span>
<span class="sd">        </span>
<span class="sd">    The maneuverability is always specified with reference to the *NADIR_POINTING* frame. The maneuver specifications </span>
<span class="sd">    describe the angular-space where the pointing axis of the sensor can be positioned. </span>
<span class="sd">    </span>
<span class="sd">    This class includes a function which can be used to obtain the Field-Of-Regard in terms of a *proxy-FOV setup*. </span>
<span class="sd">    The proxy-sensor setup is characterized by orientation (wrt the *NADIR_POINTING* frame) of the proxy-sensor (hence the proxy-sensor *SENSOR_BODY_FIXED* frame)</span>
<span class="sd">    and a spherical geometry (polygon/circle) specification of the proxy-sensor&#39;s field-of-view. This allows to calculate all coverage opportunities</span>
<span class="sd">    by the satellite-sensor pair, taking into account the satellite and/or sensor maneuverability.    </span>

<span class="sd">    :ivar maneuver_type: Type of manuevers. Accepted values are &quot;CIRCULAR&quot;, &quot;SINGLE_ROLL_ONLY&quot;, &quot;DOUBLE_ROLL_ONLY&quot;.</span>
<span class="sd">    :vartype maneuver_type: str</span>

<span class="sd">    :ivar A_roll_min: (deg) Minimum roll angle of the 1st ROLL_ONLY region. </span>
<span class="sd">    :vartype A_roll_min: float</span>

<span class="sd">    :ivar A_roll_max: (deg) Maximum roll angle of the 1st ROLL_ONLY region. </span>
<span class="sd">    :vartype A_roll_max: float</span>

<span class="sd">    :ivar B_roll_min: (deg) Minimum roll angle of the 2nd ROLL_ONLY region. </span>
<span class="sd">    :vartype B_roll_min: float</span>

<span class="sd">    :ivar B_roll_max: (deg) Maximum roll angle of the 2nd ROLL_ONLY region. </span>
<span class="sd">    :vartype B_roll_max: float</span>

<span class="sd">    :ivar diameter: (deg) Diameter of the circular maneuver region.</span>
<span class="sd">    :vartype diameter: float</span>

<span class="sd">    :param _id: Unique identifier.</span>
<span class="sd">    :paramtype _id: str</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">Type</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Enumeration of recognized maneuver types. All maneuvers are with respect to the *NADIR_POINTING* frame.</span>

<span class="sd">        :cvar CIRCULAR: This maneuver option indicates that the pointing axis can be maneuvered within a circular region (corresponding to a</span>
<span class="sd">                        specified angular diameter) *around* the z-axis (nadir-direction). The rotation about the pointing axis is unrestricted. </span>
<span class="sd">                        The resulting FOR is characterized by a proxy-sensor as follows:</span>

<span class="sd">                        This maneuver option indicates that the pointing axis can be maneuvered within a circular region (corresponding to a</span>
<span class="sd">                        specified angular diameter) *around* the z-axis (nadir-direction). The rotation about the pointing axis is unrestricted. </span>
<span class="sd">                        The resulting FOR is characterized by a proxy-sensor as follows:</span>

<span class="sd">                        * The proxy-sensor orientation is aligned to the *NADIR_POINTING* frame.</span>

<span class="sd">                        * If instrument FOV is *CIRCULAR*: </span>
<span class="sd">                            </span>
<span class="sd">                            proxy-sensor FOV is *CIRCULAR() with diameter = maneuver diameter + instrument FOV diameter</span>

<span class="sd">                        * If instrument FOV is *RECTANGULAR*: </span>
<span class="sd">                            </span>
<span class="sd">                            proxy-sensor FOV is *CIRCULAR* with diameter = maneuver diameter + diagonal angle of the instrument rectangular FOV</span>

<span class="sd">                            where diagonal angle = 2 acos( cos(angle_width/2) . cos(angle_height/2) )</span>

<span class="sd">        :vartype CIRCULAR: str</span>

<span class="sd">        :cvar SINGLE_ROLL_ONLY: This maneuver option indicates that the instrument pointing axis can be maneuvered about the roll axis (= y-axis of the *NADIR_POINTING* frame) </span>
<span class="sd">                                over a (single) range indicated by minimum and maximum roll angles. The resulting FOR characterized by a proxy-sensor is as follows:</span>

<span class="sd">                                * The proxy-sensor orientation is at a roll-position (wrt to the *NADIR_POINTING* frame) as follows:</span>
<span class="sd">                                    </span>
<span class="sd">                                    roll position = rollMin + 0.5 * (rollMax - rollMin)</span>

<span class="sd">                                * If instrument FOV is *CIRCULAR*: </span>
<span class="sd">                                    </span>
<span class="sd">                                    proxy-sensor FOV is *RECTANGULAR* with:</span>
<span class="sd">                                    </span>
<span class="sd">                                    angle width = (rollMax - rollMin) + instrument FOV diameter</span>

<span class="sd">                                    angle height = instrument FOV diameter</span>

<span class="sd">                                * If instrument FOV is *RECTANGULAR*: </span>
<span class="sd">                                    </span>
<span class="sd">                                    proxy-sensor FOV is *RECTANGULAR* with:</span>
<span class="sd">                                    </span>
<span class="sd">                                    angle width  = (rollMax - rollMin) + instrument FOV angle width</span>

<span class="sd">                                    angle height = instrument FOV angle height</span>

<span class="sd">        :vartype SINGLE_ROLL_ONLY: str</span>

<span class="sd">        :cvar DOUBLE_ROLL_ONLY: This maneuver option is similar to the *SINGLE_ROLL_ONLY* case, except that there are **two** </span>
<span class="sd">                                (potentially non-overlapping) ranges of roll-angles (minimum and maximum angles). Correspondingly </span>
<span class="sd">                                there are two proxy-sensor setups (orientation and FOV) associated with the FOR.</span>

<span class="sd">                                .. figure:: double_rollonly_maneuver.png</span>
<span class="sd">                                    :scale: 75 %</span>
<span class="sd">                                    :align: center</span>

<span class="sd">        :vartype DOUBLE_ROLL_ONLY: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CIRCULAR</span> <span class="o">=</span> <span class="s2">&quot;CIRCULAR&quot;</span>
        <span class="n">SINGLE_ROLL_ONLY</span> <span class="o">=</span> <span class="s2">&quot;SINGLE_ROLL_ONLY&quot;</span>
        <span class="n">DOUBLE_ROLL_ONLY</span> <span class="o">=</span> <span class="s2">&quot;DOUBLE_ROLL_ONLY&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maneuver_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A_roll_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A_roll_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B_roll_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B_roll_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">=</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">maneuver_type</span><span class="p">)</span> <span class="k">if</span> <span class="n">maneuver_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span> <span class="o">=</span>  <span class="nb">float</span><span class="p">(</span><span class="n">A_roll_min</span><span class="p">)</span> <span class="k">if</span> <span class="n">A_roll_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">A_roll_max</span><span class="p">)</span> <span class="k">if</span> <span class="n">A_roll_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span> <span class="o">=</span>  <span class="nb">float</span><span class="p">(</span><span class="n">B_roll_min</span><span class="p">)</span> <span class="k">if</span> <span class="n">B_roll_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">B_roll_max</span><span class="p">)</span> <span class="k">if</span> <span class="n">B_roll_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="k">if</span> <span class="n">diameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># basic checks for inputs</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid maneuver type.&quot;</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid maneuver CIRCULAR diameter.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">SINGLE_ROLL_ONLY</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">DOUBLE_ROLL_ONLY</span> <span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid roll range for SINGLE_ROLL_ONLY/ DOUBLE_ROLL_ONLY maneuver.&quot;</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid roll range for SINGLE_ROLL_ONLY/ DOUBLE_ROLL_ONLY maneuver.&quot;</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Specified Max roll angle must be numerically greater than Min roll angle for SINGLE_ROLL_ONLY/ DOUBLE_ROLL_ONLY maneuver.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">DOUBLE_ROLL_ONLY</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid roll range for DOUBLE_ROLL_ONLY maneuver.&quot;</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid roll range for DOUBLE_ROLL_ONLY maneuver.&quot;</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Specified Max roll angle must be numerically greater than Min roll angle for DOUBLE_ROLL_ONLY maneuver.&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Maneuver</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;Maneuver&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses an ``Manuever`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the manuever specifications.</span>
<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``Maneuver`` object.</span>
<span class="sd">        :rtype: :class:`instrupy.util.Maneuver`</span>

<span class="sd">        &quot;&quot;&quot;</span>                
        <span class="k">return</span> <span class="n">Maneuver</span><span class="p">(</span>
                <span class="n">maneuver_type</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maneuverType&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">A_roll_min</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;A_rollMin&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">A_roll_max</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;A_rollMax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">B_roll_min</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;B_rollMin&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">B_roll_max</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;B_rollMax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;diameter&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">_id</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the ``Maneuver`` object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``Maneuver`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">:</span>
            <span class="n">specs_dict</span><span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;maneuverType&quot;</span><span class="p">:</span> <span class="s2">&quot;CIRCULAR&quot;</span><span class="p">,</span> <span class="s2">&quot;diameter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">,</span> <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">SINGLE_ROLL_ONLY</span><span class="p">:</span>
            <span class="n">specs_dict</span><span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;maneuverType&quot;</span><span class="p">:</span> <span class="s2">&quot;SINGLE_ROLL_ONLY&quot;</span><span class="p">,</span> <span class="s2">&quot;A_rollMin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">,</span> <span class="s2">&quot;A_rollMax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span><span class="p">,</span> <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span> <span class="o">==</span> <span class="n">Maneuver</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">DOUBLE_ROLL_ONLY</span><span class="p">:</span>
            <span class="n">specs_dict</span><span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;maneuverType&quot;</span><span class="p">:</span> <span class="s2">&quot;DOUBLE_ROLL_ONLY&quot;</span><span class="p">,</span> <span class="s2">&quot;A_rollMin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">,</span> <span class="s2">&quot;A_rollMax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span><span class="p">,</span> <span class="s2">&quot;B_rollMin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span><span class="p">,</span> <span class="s2">&quot;B_rollMax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span><span class="p">,</span> <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid or no Manuever type specification.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">specs_dict</span>
    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Maneuver.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Equality test is simple one which compares the data attributes. It does not cover complex cases where the data members may be unequal, but </span>
        <span class="c1"># the Maneuver is physically the same.</span>
        <span class="c1"># note that _id data attribute may be different</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">maneuver_type</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">diameter</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">A_roll_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">B_roll_min</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">B_roll_max</span><span class="p">)</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">calc_field_of_regard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fov_sph_geom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the field-of-regard (FOR) in terms of a *proxy sensor setup* for an input sensor FOV/ scene-FOV. </span>
<span class="sd">            </span>
<span class="sd">        The FOR is characterized by (list of) :class:`ViewGeometry` container(s). </span>
<span class="sd">        This forms a *proxy-sensor setup*, which can be utilized to run coverage calculations and calculate all possible access </span>
<span class="sd">        opportunites by the sensor taking into account the (satellite + sensor) maneuverability.</span>
<span class="sd">        Note that only *CIRCULAR* or *RECTANGULAR* shaped sensor FOV are permitted for the instruments.</span>

<span class="sd">        In some scenarios where the FOR can have non-overlapping angular spaces (e.g. sidelooking</span>
<span class="sd">        SARs which can point on either &quot;side&quot;, but cannot point at the nadir), we shall have as return a list of </span>
<span class="sd">        :code:`ViewGeometry` objects, where each element of the list corresponds to a separate proxy sensor setup.</span>
<span class="sd">        All the proxy-sensor setups in the list together form the FOR.</span>

<span class="sd">        Note that always, the proxy-sensor FOV spherical-geometry &gt;= input sensor FOV spherical-geometry. </span>

<span class="sd">        .. seealso:: :class:`instrupy.util.Maneuver.Type` for calculation of the FOR for the different maneuver types.</span>

<span class="sd">        :param fov_sph_geom:  Sensor FOV spherical geometry. Must be of either *CIRCULAR* or *RECTANGULAR* shape.</span>
<span class="sd">        :paramtype fov_sph_geom: :class:`instrupy.util.SphericalGeometry`</span>

<span class="sd">        :return: Field-of-Regard characterized by a proxy sensor setup consisting of orientation with respect to the *NADIR_POINTING* frame, </span>
<span class="sd">                 and the coresponding spherical-geometry specifications. If invalid input data or no maneuver, then ``None`` is returned.</span>
<span class="sd">        :rtype: list, ViewGeometry or None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field_of_regard</span> <span class="o">=</span> <span class="kc">None</span> 
        <span class="n">mv_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maneuver_type</span>
        <span class="c1"># Evaluate FOR for CIRCULAR maneuver. proxy-sensor FOV shall be CIRCULAR shape.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mv_type</span> <span class="o">==</span> <span class="s1">&#39;CIRCULAR&#39;</span><span class="p">):</span>

            <span class="k">if</span><span class="p">(</span><span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;CIRCULAR&#39;</span><span class="p">):</span>
                <span class="n">proxy_fov_diameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">+</span> <span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">diameter</span> <span class="c1"># field-of-regard diameter</span>

            <span class="k">elif</span><span class="p">(</span><span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;RECTANGULAR&#39;</span><span class="p">):</span>
                <span class="n">diag_half_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">angle_height</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">angle_width</span><span class="p">))))</span>
                <span class="n">proxy_fov_diameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">+</span>  <span class="mi">2</span><span class="o">*</span><span class="n">diag_half_angle</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid input FOV geometry&#39;</span><span class="p">)</span>    

            <span class="n">field_of_regard</span> <span class="o">=</span> <span class="p">[</span><span class="n">ViewGeometry</span><span class="p">(</span>    <span class="n">Orientation</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">),</span> 
                                                <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s1">&#39;CIRCULAR&#39;</span><span class="p">,</span> <span class="s2">&quot;diameter&quot;</span><span class="p">:</span> <span class="n">proxy_fov_diameter</span><span class="p">})</span>
                                <span class="p">)]</span>                              

        <span class="k">def</span> <span class="nf">get_roll_only_mv_proxy_sen_specs</span><span class="p">(</span><span class="n">roll_min</span><span class="p">,</span> <span class="n">roll_max</span><span class="p">):</span>
            <span class="n">mv_angle_width_range</span> <span class="o">=</span> <span class="n">roll_max</span> <span class="o">-</span> <span class="n">roll_min</span> <span class="c1"># angular maneuver range</span>
            <span class="n">proxy_sen_roll_angle</span> <span class="o">=</span> <span class="n">roll_min</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">mv_angle_width_range</span> <span class="c1"># reference orientation</span>

            <span class="k">if</span><span class="p">(</span><span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;CIRCULAR&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Approximating FOR as rectangular shape&quot;</span><span class="p">)</span>
                <span class="n">proxy_fov_angle_height</span> <span class="o">=</span> <span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">diameter</span>
                <span class="n">proxy_fov_angle_width</span> <span class="o">=</span>  <span class="n">mv_angle_width_range</span> <span class="o">+</span> <span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">diameter</span>

            <span class="k">elif</span><span class="p">(</span><span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;RECTANGULAR&#39;</span><span class="p">):</span>
                <span class="n">proxy_fov_angle_height</span> <span class="o">=</span> <span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">angle_height</span>
                <span class="n">proxy_fov_angle_width</span> <span class="o">=</span> <span class="n">mv_angle_width_range</span> <span class="o">+</span> <span class="n">fov_sph_geom</span><span class="o">.</span><span class="n">angle_width</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid input FOV geometry&#39;</span><span class="p">)</span> 

            <span class="k">return</span> <span class="p">[</span><span class="n">proxy_sen_roll_angle</span><span class="p">,</span> <span class="n">proxy_fov_angle_height</span><span class="p">,</span> <span class="n">proxy_fov_angle_width</span><span class="p">]</span>

        <span class="c1"># Evaluate FOR for SINGLE_ROLL_ONLY maneuver. proxy-sensor FOV shall be RECTANGULAR shape.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mv_type</span> <span class="o">==</span> <span class="s1">&#39;SINGLE_ROLL_ONLY&#39;</span><span class="p">):</span>

            <span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_roll_only_mv_proxy_sen_specs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span><span class="p">)</span>

            <span class="n">field_of_regard</span> <span class="o">=</span> <span class="p">[</span><span class="n">ViewGeometry</span><span class="p">(</span>  <span class="n">Orientation</span><span class="o">.</span><span class="n">from_sideLookAngle</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="o">=</span><span class="n">w</span><span class="p">),</span> 
                                              <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span><span class="s1">&#39;RECTANGULAR&#39;</span><span class="p">,</span> <span class="s2">&quot;angleHeight&quot;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;angleWidth&quot;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
                               <span class="p">)]</span>

        <span class="c1"># Evaluate FOR for DOUBLE_ROLL_ONLY maneuver. proxy-sensor FOV shall be RECTANGULAR shape. There are two proxy-sensors (orientation, FOV).</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mv_type</span> <span class="o">==</span> <span class="s1">&#39;DOUBLE_ROLL_ONLY&#39;</span><span class="p">):</span>

            <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_roll_only_mv_proxy_sen_specs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_roll_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_roll_max</span><span class="p">)</span>
            <span class="p">[</span><span class="n">w2</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_roll_only_mv_proxy_sen_specs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_roll_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_roll_max</span><span class="p">)</span>

            <span class="n">field_of_regard</span> <span class="o">=</span> <span class="p">[</span><span class="n">ViewGeometry</span><span class="p">(</span>    <span class="n">Orientation</span><span class="o">.</span><span class="n">from_sideLookAngle</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="o">=</span><span class="n">w1</span><span class="p">),</span> 
                                                <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span><span class="s1">&#39;RECTANGULAR&#39;</span><span class="p">,</span> <span class="s2">&quot;angleHeight&quot;</span><span class="p">:</span><span class="n">x1</span><span class="p">,</span> <span class="s2">&quot;angleWidth&quot;</span><span class="p">:</span><span class="n">y1</span><span class="p">})</span>
                               <span class="p">),</span>
                               <span class="n">ViewGeometry</span><span class="p">(</span>    <span class="n">Orientation</span><span class="o">.</span><span class="n">from_sideLookAngle</span><span class="p">(</span><span class="n">ref_frame</span><span class="o">=</span><span class="s2">&quot;NADIR_POINTING&quot;</span><span class="p">,</span> <span class="n">side_look_angle</span><span class="o">=</span><span class="n">w2</span><span class="p">),</span> 
                                                <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span><span class="s1">&#39;RECTANGULAR&#39;</span><span class="p">,</span> <span class="s2">&quot;angleHeight&quot;</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="s2">&quot;angleWidth&quot;</span><span class="p">:</span><span class="n">y2</span><span class="p">})</span>
                               <span class="p">)]</span>

        
        <span class="k">return</span> <span class="n">field_of_regard</span></div>

<div class="viewcode-block" id="Antenna"><a class="viewcode-back" href="../../generated/instrupy.util.Antenna.html#instrupy.util.Antenna">[docs]</a><span class="k">class</span> <span class="nc">Antenna</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class to handle antenna related parameters and functions.</span>

<span class="sd">        .. todo:: The operating frequency is not made as an instance parameter. Change behavior in the future?</span>

<span class="sd">        :ivar shape: Antenna shape.</span>
<span class="sd">        :vartype shape: :class:`instrupy.util.Antenna.AntennaApertureShape`</span>

<span class="sd">        :ivar apertureExcitationProfile: Antenna aperture profile.</span>
<span class="sd">        :vartype apertureExcitationProfile: :class:`instrupy.util.Antenna.AntennaApertureExcitationProfile`</span>

<span class="sd">        :ivar height: [meters] Antenna height (along the along-track direction when *SENSOR_BODY_FIXED* is aligned to *NADIR_POINTING* frame).</span>
<span class="sd">        :vartype height: float</span>

<span class="sd">        :ivar width: [meters] Antenna width (along the cross-track direction when *SENSOR_BODY_FIXED* is aligned to *NADIR_POINTING* frame).</span>
<span class="sd">        :vartype antennaWidth: float</span>

<span class="sd">        :ivar apertureEfficiency: Aperture efficiency of antenna (:math:`0 &lt; \\eta_{ap} &lt; 1`).</span>
<span class="sd">        :vartype apertureEfficiency: float</span>

<span class="sd">        :ivar radiationEfficiency: Radiation efficiency of antenna (:math:`0 &lt; \\psi &lt; 1`).</span>
<span class="sd">        :vartype radiationEfficiency: float</span>

<span class="sd">        :ivar phyTemp: Antenna physical temperature in Kelvin.</span>
<span class="sd">        :vartype phyTemp: float</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">Shape</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enumeration of recognized antenna aperture shapes.</span>
<span class="sd">        </span>
<span class="sd">        :cvar RECTANGULAR: Rectangular shape.</span>
<span class="sd">        :vartype RECTANGULAR: str</span>

<span class="sd">        :cvar CIRCULAR: Circular shape. </span>
<span class="sd">        :vartype CIRCULAR: str</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RECTANGULAR</span> <span class="o">=</span> <span class="s2">&quot;RECTANGULAR&quot;</span><span class="p">,</span>
        <span class="n">CIRCULAR</span> <span class="o">=</span> <span class="s2">&quot;CIRCULAR&quot;</span>

    <span class="k">class</span> <span class="nc">ApertureExcitationProfile</span><span class="p">(</span><span class="n">EnumEntity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enumeration of recognized antenna aperture excitation profiles.</span>
<span class="sd">        </span>
<span class="sd">        :cvar UNIFORM: Uniform excitation profile.</span>
<span class="sd">        :vartype UNIFORM: str</span>

<span class="sd">        :cvar COSINE: Cosine excitation profile.</span>
<span class="sd">        :vartype COSINE: str</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">UNIFORM</span> <span class="o">=</span> <span class="s2">&quot;UNIFORM&quot;</span><span class="p">,</span>
        <span class="n">COSINE</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">apertureExcitationProfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">apertureEfficiency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radiationEfficiency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phyTemp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">Shape</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apertureExcitationProfile</span> <span class="o">=</span> <span class="n">apertureExcitationProfile</span> <span class="k">if</span> <span class="n">apertureExcitationProfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">apertureExcitationProfile</span><span class="p">,</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">ApertureExcitationProfile</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="k">if</span> <span class="n">diameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apertureEfficiency</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">apertureEfficiency</span><span class="p">)</span> <span class="k">if</span> <span class="n">apertureEfficiency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radiationEfficiency</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radiationEfficiency</span><span class="p">)</span> <span class="k">if</span> <span class="n">radiationEfficiency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phyTemp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">phyTemp</span><span class="p">)</span> <span class="k">if</span> <span class="n">phyTemp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Antenna</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;Antenna&quot;</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses an ``Antenna`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the antenna specifications.</span>
<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``Antenna`` object.</span>
<span class="sd">        :rtype: :class:`instrupy.util.Antenna`</span>

<span class="sd">        &quot;&quot;&quot;</span>             
        <span class="n">shape</span> <span class="o">=</span>  <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">apertureExcitationProfile</span> <span class="o">=</span>  <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;apertureExcitationProfile&quot;</span><span class="p">,</span> <span class="s2">&quot;UNIFORM&quot;</span><span class="p">)</span>
        <span class="n">apertureExcitationProfile</span> <span class="o">=</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">ApertureExcitationProfile</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">apertureExcitationProfile</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Antenna</span><span class="p">(</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">,</span>
                <span class="n">apertureExcitationProfile</span> <span class="o">=</span> <span class="n">apertureExcitationProfile</span><span class="p">,</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;diameter&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">apertureEfficiency</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;apertureEfficiency&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">radiationEfficiency</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radiationEfficiency&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">phyTemp</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phyTemp&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">_id</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the ``Antenna`` object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``Antenna`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                     <span class="s2">&quot;apertureExcitationProfile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">apertureExcitationProfile</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                     <span class="s2">&quot;diameter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">,</span>
                     <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> 
                     <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                     <span class="s2">&quot;apertureEfficiency&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">apertureEfficiency</span><span class="p">,</span>
                     <span class="s2">&quot;radiationEfficiency&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">radiationEfficiency</span><span class="p">,</span>
                     <span class="s2">&quot;phyTemp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phyTemp</span><span class="p">,</span>
                     <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
                    <span class="p">})</span>
    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Antenna.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Equality test is simple one which compares the data attributes.</span>
        <span class="c1"># note that _id data attribute may be different</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apertureExcitationProfile</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">apertureExcitationProfile</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">diameter</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apertureEfficiency</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">apertureEfficiency</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radiationEfficiency</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">radiationEfficiency</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phyTemp</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">phyTemp</span><span class="p">)</span>                 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
    <span class="k">def</span> <span class="nf">get_spherical_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_frequency</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the spherical geometry from the antenna shape, dimensions and aperture excitation profile.</span>

<span class="sd">        :param op_frequency: Operating frequency in Hertz.</span>
<span class="sd">        :paramtype op_frequency: float</span>

<span class="sd">        :return: ``SphericalGeometry`` object.</span>
<span class="sd">        :rtype: :class:`instrupy.util.SphericalGeometry`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate instrument FOV based on antenna shape and dimensions</span>
        <span class="n">op_wavelength</span> <span class="o">=</span>  <span class="n">Constants</span><span class="o">.</span><span class="n">speedOfLight</span><span class="o">/</span> <span class="n">op_frequency</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apertureExcitationProfile</span><span class="o">==</span><span class="n">Antenna</span><span class="o">.</span><span class="n">ApertureExcitationProfile</span><span class="o">.</span><span class="n">UNIFORM</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span><span class="p">:</span>
                <span class="c1"># calculate antenna beamwidth and hence instrument FOV. eqn 3.56a, 3.56b in [1]</span>
                <span class="n">angular_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="mf">0.88</span><span class="o">*</span><span class="n">op_wavelength</span><span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
                <span class="n">angular_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="mf">0.88</span><span class="o">*</span><span class="n">op_wavelength</span><span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

                <span class="n">instru_sph_geom_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;RECTANGULAR&quot;</span><span class="p">,</span> <span class="s2">&quot;angleHeight&quot;</span><span class="p">:</span> <span class="n">angular_height</span><span class="p">,</span> <span class="s2">&quot;angleWidth&quot;</span><span class="p">:</span> <span class="n">angular_width</span> <span class="p">}</span> 
            
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">:</span>
                
                <span class="n">cone_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">op_wavelength</span><span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">)</span> <span class="c1"># eqn 3.66 in [1]</span>
                <span class="n">instru_sph_geom_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;CIRCULAR&quot;</span><span class="p">,</span> <span class="s2">&quot;diameter&quot;</span><span class="p">:</span> <span class="n">cone_angle</span><span class="p">}</span> 
            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">return</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">instru_sph_geom_dict</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_beam_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_frequency</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the beam-efficiency.</span>

<span class="sd">        :param op_frequency: Operating frequency in Hertz.</span>
<span class="sd">        :paramtype op_frequency: float</span>

<span class="sd">        :return: Beam-efficiency or NaN in case result could not be computed.</span>
<span class="sd">        :rtype: float or np.NaN</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate instrument FOV based on antenna shape and dimensions</span>
        <span class="n">op_wavelength</span> <span class="o">=</span>  <span class="n">Constants</span><span class="o">.</span><span class="n">speedOfLight</span><span class="o">/</span> <span class="n">op_frequency</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apertureExcitationProfile</span><span class="o">==</span><span class="n">Antenna</span><span class="o">.</span><span class="n">ApertureExcitationProfile</span><span class="o">.</span><span class="n">UNIFORM</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">:</span> <span class="c1"># square antenna</span>
                    <span class="k">return</span> <span class="n">op_wavelength</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="c1"># Eqn 3.73a in [1]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apertureExcitationProfile</span><span class="o">==</span><span class="n">Antenna</span><span class="o">.</span><span class="n">ApertureExcitationProfile</span><span class="o">.</span><span class="n">COSINE</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">Antenna</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">:</span> <span class="c1"># square antenna</span>
                    <span class="k">return</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">op_wavelength</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="c1"># Eqn 3.73a in [1]    </span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="c1"># return NaN if control reaches this stage.</span></div>

<div class="viewcode-block" id="MathUtilityFunctions"><a class="viewcode-back" href="../../generated/instrupy.util.MathUtilityFunctions.html#instrupy.util.MathUtilityFunctions">[docs]</a><span class="k">class</span> <span class="nc">MathUtilityFunctions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class aggregating various mathematical computation functions. &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Normalize a input vector.</span>

<span class="sd">            :param v: Input vector</span>
<span class="sd">            :paramtype v: list, float</span>

<span class="sd">            :return: Normalized vector</span>
<span class="sd">            :rtype: :obj:`np.array`, float</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Encountered division by zero in vector normalization function.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="n">norm</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">angle_between_vectors</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Find angle between two input vectors in radians. Use the dot-product relationship to obtain the angle.</span>
<span class="sd">        </span>
<span class="sd">            :param vector1: Input vector 1</span>
<span class="sd">            :paramtype vector1: list, float</span>

<span class="sd">            :param vector2: Input vector 2</span>
<span class="sd">            :paramtype vector2: list, float</span>

<span class="sd">            :return: [rad] Angle between the vectors, calculated using dot-product relationship.</span>
<span class="sd">            :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unit_vec1</span> <span class="o">=</span> <span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span>
        <span class="n">unit_vec2</span> <span class="o">=</span> <span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">vector2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_vec1</span><span class="p">,</span> <span class="n">unit_vec2</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_closest_value_in_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Find the value in an array closest to the supplied scalar value.</span>

<span class="sd">            :param array: Array under consideration</span>
<span class="sd">            :paramtype array: list, float</span>

<span class="sd">            :param value: Value under consideration</span>
<span class="sd">            :paramtype value: float</span>

<span class="sd">            :return: Value in array corresponding to one which is closest to supplied value, Index of the value in array</span>
<span class="sd">            :rtype: list, float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="GeoUtilityFunctions"><a class="viewcode-back" href="../../generated/instrupy.util.GeoUtilityFunctions.html#instrupy.util.GeoUtilityFunctions">[docs]</a><span class="k">class</span> <span class="nc">GeoUtilityFunctions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class aggregating various geography related functions. &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_satellite_footprint_speed</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute satellite footprint (**at nadir** on ground-plane) linear speed in [m/s].</span>

<span class="sd">            :param r: [distance] postion vector of satellite in ECI equatorial frame</span>
<span class="sd">            :paramtype r: list, float</span>

<span class="sd">            :param v: [distance/s] velocity vector of satellite in ECI equatorial frame</span>
<span class="sd">            :paramtype v: list, float</span>

<span class="sd">            :return: speed of satellite footprint in [m/s]</span>
<span class="sd">            :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Calculate angular velocity of satellite</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># angular velocity vector in radians per second</span>
        
        <span class="c1"># compensate for Earths rotation</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Constants</span><span class="o">.</span><span class="n">angularSpeedOfEarthInRadPerSec</span><span class="p">])</span>

        <span class="c1"># Find linear speed of satellite footprint on ground [m/s].   </span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span><span class="o">*</span><span class="mf">1e3</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">latlonalt_To_Cartesian</span><span class="p">(</span><span class="n">lat_deg</span><span class="p">,</span> <span class="n">lon_deg</span><span class="p">,</span> <span class="n">alt_km</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; *LLA to ECEF vector considering Earth as sphere with a radius equal to the equatorial radius.*</span>

<span class="sd">            :param lat_deg: [deg] geocentric latitude </span>
<span class="sd">            :paramtype lat_deg: float</span>

<span class="sd">            :param lon_deg: [deg] geocentric longitude</span>
<span class="sd">            :paramtype lon_deg: float</span>

<span class="sd">            :param alt_km: [km] Altitude</span>
<span class="sd">            :paramtype alt_km: float</span>

<span class="sd">            :return: [km] Position vector in ECEF</span>
<span class="sd">            :rtype: float, list</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lat_deg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lon_deg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">lon_deg</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">lon_deg</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lon_deg</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span> <span class="o">+</span> <span class="n">alt_km</span>
        <span class="n">position_vector_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span> <span class="o">*</span> <span class="n">R</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span> <span class="o">*</span> <span class="n">R</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">]</span> <span class="p">)</span>     

        <span class="k">return</span> <span class="n">position_vector_km</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">latlonaltGeodetic_To_Cartesian</span><span class="p">(</span><span class="n">lat_deg</span><span class="p">,</span> <span class="n">lon_deg</span><span class="p">,</span> <span class="n">alt_km</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; *LLA to ECEF vector considering Earth as WGS-84 ellipsoid.*</span>

<span class="sd">            :param lat_deg: [deg] WGS-84 geodetic latitude </span>
<span class="sd">            :paramtype: float</span>

<span class="sd">            :param lon_deg: [deg] WGS-84 geodetic longitude</span>
<span class="sd">            :paramtype lon_deg: float</span>

<span class="sd">            :param alt_km: [km] Altitude</span>
<span class="sd">            :paramtype alt_km: float</span>

<span class="sd">            :return: [km] Position vector in WGS-84 ECEF</span>
<span class="sd">            :rtype: float, list</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">a</span> <span class="o">=</span> <span class="mi">6378137</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">6356752.3142</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span>
        <span class="n">e_sq</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="n">f</span><span class="p">)</span>

        <span class="n">lamb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lat_deg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lon_deg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">lon_deg</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">lon_deg</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lon_deg</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">alt_km</span><span class="o">*</span><span class="mf">1e3</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lamb</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e_sq</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>

        <span class="n">sin_lambda</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lamb</span><span class="p">)</span>
        <span class="n">cos_lambda</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lamb</span><span class="p">)</span>
        <span class="n">sin_phi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">cos_phi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos_lambda</span> <span class="o">*</span> <span class="n">cos_phi</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos_lambda</span> <span class="o">*</span> <span class="n">sin_phi</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e_sq</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin_lambda</span>

        <span class="n">position_vector_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">y</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">z</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">]</span> <span class="p">)</span>     

        <span class="k">return</span> <span class="n">position_vector_km</span>

    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">geo2eci</span><span class="p">(</span><span class="n">gcoord</span><span class="p">,</span> <span class="n">JDtime</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; *Convert geographic spherical coordinates to Earth-centered inertial coords.*    </span>
<span class="sd">             </span>
<span class="sd">        :param gcoord: Geographic coordinates of point [latitude [deg] ,longitude [deg], altitude [km]]. Geographic coordinates assume the Earth is a perfect sphere, with radius </span>
<span class="sd">                     equal to its equatorial radius.</span>
<span class="sd">        :paramtype  gcoord: list or tuple, (float, float, float)</span>

<span class="sd">        :param JDtime: Julian Day time.</span>
<span class="sd">        :paramtype JDtime: float</span>

<span class="sd">        :return: A 3-element array of ECI [X,Y,Z] coordinates in kilometers. The TOD epoch is the supplied JDtime.                           </span>
<span class="sd">        :rtype: list, (float, float, float)</span>

<span class="sd">        .. seealso:: </span>
<span class="sd">            * :mod:`JD2GMST`</span>
<span class="sd">            * `IDL Astronomy Users Library &lt;https://idlastro.gsfc.nasa.gov/ftp/pro/astro/geo2eci.pro&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">               ECIcoord = geo2eci([0,0,0], 2452343.38982663)</span>
<span class="sd">               print(ECIcoord)</span>
<span class="sd">              -3902.9606       5044.5548       0.0000000</span>
<span class="sd">        </span>
<span class="sd">        (The above is the ECI coordinates of the intersection of the equator and</span>
<span class="sd">        Greenwich&#39;s meridian on 2002/03/09 21:21:21.021)             </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">gcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">gcoord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="n">gcoord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
               
        <span class="n">gst</span> <span class="o">=</span> <span class="n">GeoUtilityFunctions</span><span class="o">.</span><span class="n">JD2GMST</span><span class="p">(</span><span class="n">JDtime</span><span class="p">)</span>
        
        <span class="n">angle_sid</span><span class="o">=</span><span class="n">gst</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">24.0</span> <span class="c1"># sidereal angle</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">lon</span> <span class="o">+</span> <span class="n">angle_sid</span> <span class="c1"># azimuth</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span> <span class="n">alt</span> <span class="o">+</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="p">(</span> <span class="n">alt</span> <span class="o">+</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span> <span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">]</span>
        
   
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eci2geo</span><span class="p">(</span><span class="n">ecicoord</span><span class="p">,</span> <span class="n">JDtime</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; *Convert Earth-centered inertial coords to geographic spherical coordinates.*    </span>
<span class="sd">             https://idlastro.gsfc.nasa.gov/ftp/pro/astro/eci2geo.pro</span>

<span class="sd">        :param ecicoord: A 3-element array of ECI [X,Y,Z] coordinates in kilometers.</span>
<span class="sd">        :paramtype  ecicoord: list or tuple, (float, float, float)</span>

<span class="sd">        :param JDtime: Julian Day time.</span>
<span class="sd">        :paramtype JDtime: float</span>

<span class="sd">        :return: Geographic coordinates of point [latitude [deg] ,longitude [deg], altitude [km]]. </span>
<span class="sd">                 Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.                          </span>
<span class="sd">        :rtype: list, (float, float, float)</span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecicoord</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">gst</span> <span class="o">=</span> <span class="n">GeoUtilityFunctions</span><span class="o">.</span><span class="n">JD2GMST</span><span class="p">(</span><span class="n">JDtime</span><span class="p">)</span>        
        <span class="n">angle_sid</span><span class="o">=</span><span class="n">gst</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">24.0</span> <span class="c1"># sidereal angle</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">((</span><span class="n">theta</span> <span class="o">-</span> <span class="n">angle_sid</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> 

        <span class="n">r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>                         
        
        <span class="n">alt</span><span class="o">=</span><span class="n">r</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">-</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span>

        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="p">[</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">,</span><span class="n">alt</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">JD2GMST</span><span class="p">(</span><span class="n">JD</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert Julian Day to Greenwich Mean Sidereal Time.</span>
<span class="sd">            Reference `USNO NAVY &lt;https://aa.usno.navy.mil/faq/docs/GAST.php&gt;`_</span>

<span class="sd">            :param JD: Julian Date UT1</span>
<span class="sd">            :paramtype JD: float</span>

<span class="sd">            :return: [hrs] Greenwich Mean Sidereal Time at the corresponding JD</span>
<span class="sd">            :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">JD</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">if</span><span class="p">(</span><span class="n">_x</span> <span class="o">&gt;</span> <span class="n">JD</span><span class="p">):</span>
            <span class="n">JD0</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">JD</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">JD0</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">JD</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
      
        <span class="n">D</span> <span class="o">=</span> <span class="n">JD</span> <span class="o">-</span> <span class="mf">2451545.0</span>
        <span class="n">D0</span> <span class="o">=</span> <span class="n">JD0</span> <span class="o">-</span> <span class="mf">2451545.0</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">JD</span> <span class="o">-</span> <span class="n">JD0</span><span class="p">)</span><span class="o">*</span><span class="mf">24.0</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="mf">36525.0</span>

        <span class="c1"># Greenwich mean sidereal time in hours</span>
        <span class="n">GMST</span> <span class="o">=</span> <span class="mf">6.697374558</span> <span class="o">+</span> <span class="mf">0.06570982441908</span><span class="o">*</span><span class="n">D0</span> <span class="o">+</span> <span class="mf">1.00273790935</span><span class="o">*</span><span class="n">H</span> <span class="o">+</span> <span class="mf">0.000026</span><span class="o">*</span><span class="n">T</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="n">GMST</span> <span class="o">=</span> <span class="n">GMST</span> <span class="o">%</span> <span class="mi">24</span>

        <span class="k">return</span> <span class="n">GMST</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SunVector_ECIeq</span><span class="p">(</span><span class="n">Time_JDUT1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find Sun Vector in Earth Centered Inertial (ECI) equatorial frame.</span>
<span class="sd">           Algorithm in David A.Vallado, Fundamental of Astrodynamics and Applications, 4th ed, Page 280.</span>
<span class="sd">           Also see accompanying software scripts with the book.</span>

<span class="sd">           :param Time_JDUT1: Time in Julian Day UT1</span>
<span class="sd">           :paramtype Time_JDUT1: float</span>

<span class="sd">           :return: Sun-vector in ECI equatorial frame (km)</span>
<span class="sd">           :rtype: list, float</span>
<span class="sd">           </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T_UT1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Time_JDUT1</span> <span class="o">-</span> <span class="mf">2451545.0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">36525</span>

        <span class="n">T_TDB</span> <span class="o">=</span> <span class="n">T_UT1</span>

        <span class="n">lambda_M_deg</span> <span class="o">=</span> <span class="p">(</span><span class="mf">280.460</span> <span class="o">+</span> <span class="mf">36000.77</span><span class="o">*</span><span class="n">T_UT1</span><span class="p">)</span>
        <span class="n">lambda_M_deg</span> <span class="o">=</span> <span class="n">lambda_M_deg</span> <span class="o">%</span> <span class="mi">360</span>
        
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">((</span><span class="mf">357.5277233</span> <span class="o">+</span> <span class="mf">35999.05034</span><span class="o">*</span><span class="n">T_TDB</span><span class="p">))</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">M</span>

        <span class="n">lambda_ecliptic_deg</span> <span class="o">=</span> <span class="p">(</span><span class="n">lambda_M_deg</span> <span class="o">+</span> <span class="mf">1.914666471</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.019994643</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">))</span>
        <span class="n">lambda_ecliptic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lambda_ecliptic_deg</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span>

        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">23.439291</span> <span class="o">-</span> <span class="mf">0.0130042</span><span class="o">*</span><span class="n">T_TDB</span><span class="p">)</span>

        
        <span class="c1"># find the unit Sun vector in ECI frame</span>
        <span class="n">unitSv_ECI</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lambda_ecliptic</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lambda_ecliptic</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lambda_ecliptic</span><span class="p">)]</span>
        
        
        <span class="c1"># magnitude of distance to the Sun from Earth center (note: not from the spacecraft)</span>
        <span class="n">r_Sun_km</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.000140612</span> <span class="o">-</span> <span class="mf">0.016708617</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.000139589</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">))</span> <span class="o">*</span> <span class="mf">149597870.700</span>

        
        <span class="c1"># complete vector of Sun from Earth Center (ECI equatorial frame)</span>
        <span class="n">Sv_ECI_km</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">r_Sun_km</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unitSv_ECI</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">Sv_ECI_km</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">checkLOSavailability</span><span class="p">(</span><span class="n">object1_pos</span><span class="p">,</span> <span class="n">object2_pos</span><span class="p">,</span> <span class="n">obstacle_radius</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Determine if line-of-sight exists</span>
<span class="sd">             Algorithm from Page 198 Fundamental of Astrodynamics and Applications, David A.Vallado is used. The first algorithm</span>
<span class="sd">             described is used.</span>

<span class="sd">             :param object1_pos: Object 1 position vector</span>
<span class="sd">             :paramtype object1_pos: float</span>

<span class="sd">             :param object2_pos: Object2 position vector</span>
<span class="sd">             :paramtype object2_pos: float</span>

<span class="sd">             :param obstacle_radius: Radius of spherical obstacle</span>
<span class="sd">             :paramtype obstacle_radius: float</span>

<span class="sd">             :return: T/F flag indicating availability of line of sight from object1 to object2.</span>
<span class="sd">             :rtype: bool</span>

<span class="sd">             .. note: The frame of reference for describing the object positions must be centered at spherical obstacle.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">obj1_unitVec</span> <span class="o">=</span> <span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">object1_pos</span><span class="p">)</span>
        <span class="n">obj2_unitVec</span> <span class="o">=</span> <span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">object2_pos</span><span class="p">)</span>  

        <span class="c1"># This condition tends to give a numerical error, so solve for it independently.</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">obj1_unitVec</span><span class="p">,</span> <span class="n">obj2_unitVec</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">eps</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">eps</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span> 
                <span class="n">x</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">theta</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                
        <span class="n">obj1_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">object1_pos</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">obj1_r</span> <span class="o">-</span> <span class="n">obstacle_radius</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">):</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">obstacle_radius</span><span class="o">/</span><span class="n">obj1_r</span><span class="p">)</span>
        <span class="k">elif</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">obj1_r</span> <span class="o">-</span> <span class="n">obstacle_radius</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">):</span>
            <span class="n">theta1</span> <span class="o">=</span>  <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span> <span class="c1"># object1 is inside the obstacle</span>

        <span class="n">obj2_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">object2_pos</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">obj2_r</span> <span class="o">-</span> <span class="n">obstacle_radius</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">):</span>
            <span class="n">theta2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">obstacle_radius</span><span class="o">/</span><span class="n">obj2_r</span><span class="p">)</span>
        <span class="k">elif</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">obj2_r</span> <span class="o">-</span> <span class="n">obstacle_radius</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">):</span>
            <span class="n">theta2</span> <span class="o">=</span>  <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span> <span class="c1"># object2 is inside the obstacle</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">theta2</span> <span class="o">&lt;</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>     

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_sun_zenith</span><span class="p">(</span><span class="n">time_JDUT1</span><span class="p">,</span> <span class="n">pos_km</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute the Sun zenith angle at the given time and location. </span>

<span class="sd">            :param time_JDUT1: Time in Julian Day UT1</span>
<span class="sd">            :paramtype time_JDUT1: float</span>

<span class="sd">            :param pos_km: Position vector [km] of point in ECI frame at which the Sun elevation angle is to be calculated.  </span>
<span class="sd">            :paramtype pos_km: list, float</span>

<span class="sd">            :returns: Sun zenith angle in [radians], Distance from Sun in [km]</span>
<span class="sd">            :rtype: list, float</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate Sun-vector in ECI frame</span>
        <span class="n">sunVector_km</span> <span class="o">=</span> <span class="n">GeoUtilityFunctions</span><span class="o">.</span><span class="n">SunVector_ECIeq</span><span class="p">(</span><span class="n">time_JDUT1</span><span class="p">)</span>
        <span class="c1"># verify point-of-interest is below in night region</span>
        <span class="k">if</span><span class="p">(</span><span class="n">GeoUtilityFunctions</span><span class="o">.</span><span class="n">checkLOSavailability</span><span class="p">(</span><span class="n">pos_km</span><span class="p">,</span> <span class="n">sunVector_km</span><span class="p">,</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># calculate sun to target vector</span>
        <span class="n">Sun2Tar_pos_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_km</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sunVector_km</span><span class="p">)</span>
        <span class="c1"># calculate solar incidence angle</span>
        <span class="n">solar_zenith_angle_rad</span> <span class="o">=</span> <span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">pos_km</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Sun2Tar_pos_km</span><span class="p">))</span>

        <span class="n">solar_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Sun2Tar_pos_km</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">solar_zenith_angle_rad</span><span class="p">,</span> <span class="n">solar_distance</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_derived_satellite_coords</span><span class="p">(</span><span class="n">tObs_JDUT1</span><span class="p">,</span> <span class="n">obs_position_km</span><span class="p">,</span> <span class="n">obs_vel_vec_kmps</span><span class="p">,</span> <span class="n">target_position_km</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The satellite state supplied to the function may not be exactly at the middle of the access interval, and hence the state supplied would</span>
<span class="sd">            not correspond to time at which the satellite to point-of-interest line is exactly orthogonal to the ground-track. </span>

<span class="sd">            :param tObs_JDUT1: Observation time in Julian Day UT1</span>
<span class="sd">            :paramtype tObs_JDUT1: float</span>

<span class="sd">            :param obs_position_km: Spacecraft position vector</span>
<span class="sd">            :paramtype obs_position_km: list, float</span>

<span class="sd">            :param obs_vel_vec_kmps: Observer velocity vector</span>
<span class="sd">            :paramtype obs_vel_vec_kmps: list, float</span>

<span class="sd">            :param target_position_km: Target (object being observed) position vector</span>
<span class="sd">            :paramtype target_position_km: list, float</span>

<span class="sd">            :returns: Derived observation time, position, range, altitude and incidence angle as a dictionary.</span>
<span class="sd">            :rtype: dict, float</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obs_position_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obs_position_km</span><span class="p">)</span>
        <span class="n">obs_vel_vec_kmps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obs_vel_vec_kmps</span><span class="p">)</span>
        <span class="n">target_position_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_position_km</span><span class="p">)</span>

        <span class="c1">#  Calculate range vector between spacecraft and POI (Target)</span>
        <span class="n">range_vector_km</span> <span class="o">=</span> <span class="n">target_position_km</span> <span class="o">-</span> <span class="n">obs_position_km</span>

        <span class="n">alt_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">obs_position_km</span><span class="p">)</span> <span class="o">-</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span>
        <span class="n">look_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">range_vector_km</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">obs_position_km</span><span class="p">)))</span>
        <span class="n">incidence_angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">look_angle</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span> <span class="o">+</span> <span class="n">alt_km</span><span class="p">)</span><span class="o">/</span><span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span><span class="p">)</span>

        <span class="c1"># 1. Get vector perpendicular to the cross-orbital plane, using the satellite velocity vector.</span>
        <span class="n">crossOrbPlaneNorVec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">obs_vel_vec_kmps</span><span class="p">))</span>
        <span class="c1"># 2. Calculate projection of range-vector onto the cross-orbital-plane        </span>
        <span class="n">r_vec_projCrossOrbPlane_km</span> <span class="o">=</span> <span class="n">range_vector_km</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">range_vector_km</span><span class="p">,</span> <span class="n">crossOrbPlaneNorVec</span><span class="p">)</span><span class="o">*</span><span class="n">crossOrbPlaneNorVec</span><span class="p">)</span>      
        <span class="c1"># 3. Calculate the range-vector and viewing geometry to the &quot;derived&quot; observer position</span>
        <span class="n">derived_range_vec_km</span> <span class="o">=</span> <span class="n">r_vec_projCrossOrbPlane_km</span>
        <span class="n">derived_obs_pos_km</span> <span class="o">=</span> <span class="n">target_position_km</span> <span class="o">-</span> <span class="n">derived_range_vec_km</span>
        <span class="n">derived_look_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">derived_range_vec_km</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">MathUtilityFunctions</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">derived_obs_pos_km</span><span class="p">)))</span>

        <span class="n">derived_alt_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">derived_obs_pos_km</span><span class="p">)</span> <span class="o">-</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span>
        <span class="n">derived_incidence_angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">derived_look_angle</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span> <span class="o">+</span> <span class="n">derived_alt_km</span><span class="p">)</span><span class="o">/</span><span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span><span class="p">)</span>

        <span class="n">travel_dis_km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">derived_obs_pos_km</span> <span class="o">-</span> <span class="n">obs_position_km</span><span class="p">)</span> 
        <span class="n">travel_time_s</span> <span class="o">=</span> <span class="n">travel_dis_km</span><span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">obs_vel_vec_kmps</span><span class="p">)</span>
        <span class="n">derived_obsTime_JDUT1</span> <span class="o">=</span> <span class="n">tObs_JDUT1</span> <span class="o">+</span> <span class="n">travel_time_s</span>
        
        <span class="c1">#return {&quot;derived_obsTime_JDUT1&quot;: tObs_JDUT1, &quot;derived_obs_pos_km&quot;: obs_position_km, &quot;derived_range_vec_km&quot;: range_vector_km, &quot;derived_alt_km&quot;: alt_km, &quot;derived_incidence_angle_rad&quot;: incidence_angle_rad}</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;derived_obsTime_JDUT1&quot;</span><span class="p">:</span> <span class="n">derived_obsTime_JDUT1</span><span class="p">,</span> <span class="s2">&quot;derived_obs_pos_km&quot;</span><span class="p">:</span> <span class="n">derived_obs_pos_km</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;derived_range_vec_km&quot;</span><span class="p">:</span> <span class="n">derived_range_vec_km</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;derived_alt_km&quot;</span><span class="p">:</span> <span class="n">derived_alt_km</span><span class="p">,</span> <span class="s2">&quot;derived_incidence_angle_rad&quot;</span><span class="p">:</span> <span class="n">derived_incidence_angle_rad</span><span class="p">}</span>
      
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_transmission_Obs2Space</span><span class="p">(</span><span class="n">wav_low_m</span><span class="p">,</span> <span class="n">wav_high_m</span><span class="p">,</span> <span class="n">obs_zenith_angle_rad</span><span class="p">,</span> <span class="n">wav_step_percm</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Observer to space transmission loss</span>

<span class="sd">            :returns: transmissitivity in steps of 5cm-1</span>
<span class="sd">            :rtype: array, float</span>
<span class="sd">        &#39;&#39;&#39;</span>        
        <span class="n">obs_alt_km</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">wav_low_nm</span> <span class="o">=</span> <span class="n">wav_low_m</span><span class="o">*</span><span class="mf">1e9</span>
        <span class="n">wav_high_nm</span> <span class="o">=</span> <span class="n">wav_high_m</span><span class="o">*</span><span class="mf">1e9</span>
        <span class="n">obs_zenith_angle_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">obs_zenith_angle_rad</span><span class="p">)</span>
        
        <span class="n">c1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="c1"># US standard</span>
            <span class="s1">&#39;h1&#39;</span><span class="p">:</span> <span class="n">obs_alt_km</span><span class="p">,</span>
            <span class="s1">&#39;angle&#39;</span><span class="p">:</span> <span class="n">obs_zenith_angle_deg</span><span class="p">,</span> 
            <span class="s1">&#39;wlshort&#39;</span><span class="p">:</span> <span class="n">wav_low_nm</span><span class="p">,</span>
            <span class="s1">&#39;wllong&#39;</span><span class="p">:</span> <span class="n">wav_high_nm</span><span class="p">,</span>
            <span class="s1">&#39;wlstep&#39;</span><span class="p">:</span> <span class="n">wav_step_percm</span><span class="p">,</span>
            <span class="p">}</span>
        
        <span class="n">TR</span> <span class="o">=</span> <span class="n">lowtran</span><span class="o">.</span><span class="n">transmittance</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
        <span class="n">TR</span> <span class="o">=</span> <span class="n">TR</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">TR</span><span class="p">[</span><span class="s1">&#39;wavelength_nm&#39;</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># LowTran sometimes returns a entry with &#39;0&#39; wavelength (when the bandwidth is not &quot;compatible&quot; with the step-size)</span>
        <span class="k">return</span> <span class="n">TR</span> 
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_eca</span><span class="p">(</span><span class="n">fov_deg</span><span class="p">,</span> <span class="n">alt_km</span><span class="p">):</span>

        <span class="n">RE</span> <span class="o">=</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span> 
        <span class="n">sinRho</span> <span class="o">=</span> <span class="n">RE</span><span class="o">/</span><span class="p">(</span><span class="n">RE</span> <span class="o">+</span> <span class="n">alt_km</span><span class="p">)</span>
        <span class="n">hfov_deg</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">fov_deg</span>
        <span class="n">elev_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">hfov_deg</span><span class="p">))</span><span class="o">/</span><span class="n">sinRho</span><span class="p">))</span>
        <span class="n">lambda_deg</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">-</span> <span class="n">hfov_deg</span> <span class="o">-</span> <span class="n">elev_deg</span> <span class="c1"># half-earth centric angle </span>
        <span class="n">eca_deg</span> <span class="o">=</span> <span class="n">lambda_deg</span><span class="o">*</span><span class="mi">2</span> <span class="c1"># total earth centric angle</span>

        <span class="k">return</span> <span class="n">eca_deg</span></div>


<div class="viewcode-block" id="FileUtilityFunctions"><a class="viewcode-back" href="../../generated/instrupy.util.FileUtilityFunctions.html#instrupy.util.FileUtilityFunctions">[docs]</a><span class="k">class</span> <span class="nc">FileUtilityFunctions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Functions to help in processing of files of various formats.&quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">json_doc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses a dictionary from a JSON-formatted string, dictionary, or file.&quot;&quot;&quot;</span>
        <span class="c1"># convert json string or file to dictionary (if necessary)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">json_doc</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_doc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="s1">&#39;read&#39;</span><span class="p">):</span>
            <span class="n">json_doc</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_doc</span><span class="p">)</span>
        <span class="c1"># if pre-formatted, return directly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">json_doc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="n">Entity</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">json_doc</span>
        <span class="c1"># if list, recursively parse each element and return mapped list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_doc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">FileUtilityFunctions</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">json_doc</span><span class="p">)</span>
        <span class="c1"># otherwise use class method to initialize from normalized dictionary</span>
        <span class="k">return</span> <span class="n">json_doc</span> </div>



</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, BAERI.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>