

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>orbitpy.coveragecalculator &mdash; OrbitPy 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> OrbitPy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../miscellaneous.html">Miscellaneous</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">OrbitPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>orbitpy.coveragecalculator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for orbitpy.coveragecalculator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">.. module:: coveragecalculator</span>

<span class="sd">:synopsis: *Module providing classes and functions to handle coverage related calculations.*</span>

<span class="sd">.. todo:: Revise to include coverage calculations of spacecrafts without sensors.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">propcov</span>
<span class="kn">from</span> <span class="nn">instrupy.util</span> <span class="kn">import</span> <span class="n">Entity</span>
<span class="kn">from</span> <span class="nn">orbitpy.grid</span> <span class="kn">import</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">orbitpy.util</span> <span class="kn">import</span> <span class="n">Spacecraft</span><span class="p">,</span> <span class="n">OutputInfoUtility</span>
<span class="kn">import</span> <span class="nn">orbitpy.util</span>
<span class="kn">from</span> <span class="nn">instrupy.util</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">SphericalGeometry</span><span class="p">,</span> <span class="n">GeoUtilityFunctions</span><span class="p">,</span> <span class="n">Constants</span>

<span class="n">DAYS_PER_SEC</span> <span class="o">=</span> <span class="mf">1.1574074074074074074074074074074e-5</span>

<div class="viewcode-block" id="CoverageCalculatorFactory"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.CoverageCalculatorFactory.html#orbitpy.coveragecalculator.CoverageCalculatorFactory">[docs]</a><span class="k">class</span> <span class="nc">CoverageCalculatorFactory</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Factory class which allows to register and invoke the appropriate coverage calculator class. </span>
<span class="sd">    </span>
<span class="sd">    The following classes are registered in the factory:</span>
<span class="sd">    </span>
<span class="sd">    * :class:`GridCoverage` </span>
<span class="sd">    * :class:`PointingOptionsCoverage`</span>
<span class="sd">    * :class:`PointingOptionsWithGridCoverage`</span>
<span class="sd">    * :class:`SpecularCoverage`</span>
<span class="sd">     </span>
<span class="sd">    Additional user-defined coverage calculator classes can be registered as shown below: </span>

<span class="sd">    Usage: </span>
<span class="sd">    </span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        </span>
<span class="sd">        factory = orbitpy.CoverageCalculatorFactory()</span>
<span class="sd">        factory.register_coverage_calculator(&#39;Custom Coverage Finder&#39;, CoverageFinder) # CoverageFinder is the user class</span>
<span class="sd">        cov_calc = factory.get_coverage_calculator(&#39;CoverageFinder&#39;)</span>

<span class="sd">    :ivar _creators: Dictionary mapping coverage type label to the appropriate coverage calculator class. </span>
<span class="sd">    :vartype _creators: dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CoverageCalculatorFactory.__init__"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.CoverageCalculatorFactory.html#orbitpy.coveragecalculator.CoverageCalculatorFactory.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_creators</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_coverage_calculator</span><span class="p">(</span><span class="s1">&#39;GRID COVERAGE&#39;</span><span class="p">,</span> <span class="n">GridCoverage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_coverage_calculator</span><span class="p">(</span><span class="s1">&#39;POINTING OPTIONS COVERAGE&#39;</span><span class="p">,</span> <span class="n">PointingOptionsCoverage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_coverage_calculator</span><span class="p">(</span><span class="s1">&#39;POINTING OPTIONS WITH GRID COVERAGE&#39;</span><span class="p">,</span> <span class="n">PointingOptionsWithGridCoverage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_coverage_calculator</span><span class="p">(</span><span class="s1">&#39;SPECULAR COVERAGE&#39;</span><span class="p">,</span> <span class="n">SpecularCoverage</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoverageCalculatorFactory.register_coverage_calculator"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.CoverageCalculatorFactory.html#orbitpy.coveragecalculator.CoverageCalculatorFactory.register_coverage_calculator">[docs]</a>    <span class="k">def</span> <span class="nf">register_coverage_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span> <span class="n">creator</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to register coverage calculators.</span>

<span class="sd">        :var _type: Coverage calculator type (label).</span>
<span class="sd">        :vartype _type: str</span>

<span class="sd">        :var creator: Coverage calculator class.</span>
<span class="sd">        :vartype creator: Coverage calculator class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_creators</span><span class="p">[</span><span class="n">_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">creator</span></div>

<div class="viewcode-block" id="CoverageCalculatorFactory.get_coverage_calculator"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.CoverageCalculatorFactory.html#orbitpy.coveragecalculator.CoverageCalculatorFactory.get_coverage_calculator">[docs]</a>    <span class="k">def</span> <span class="nf">get_coverage_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to get the appropriate coverage calculator instance.</span>

<span class="sd">        :var specs: Coverage calculator specifications which also contains a valid coverage calculator</span>
<span class="sd">                    type in the &quot;@type&quot; dict key. The coverage calculator type is valid if it has been</span>
<span class="sd">                    registered with the ``CoverageCalculatorFactory`` instance.</span>
<span class="sd">        :vartype _type: dict</span>

<span class="sd">        :return: The appropriate coverage calculator object initialized to the input specifications.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.GridCoverage` or :class:`orbitpy.coveragecalculator.PointingOptionsCoverage` or :class:`orbitpy.coveragecalculator.PointingOptionsWithGridCoverage` or custom coverage calculator class.</span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;@type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Coverage Calculator type key/value pair not found in specifications dictionary.&#39;</span><span class="p">)</span>

        <span class="n">creator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_creators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">creator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">creator</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="helper_extract_coverage_parameters_of_spacecraft"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.helper_extract_coverage_parameters_of_spacecraft.html#orbitpy.coveragecalculator.helper_extract_coverage_parameters_of_spacecraft">[docs]</a><span class="k">def</span> <span class="nf">helper_extract_coverage_parameters_of_spacecraft</span><span class="p">(</span><span class="n">spc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Helper function to extract tuples of (instrument_id, mode_id, scene-field-of-view, field-of-regard, pointing_option(s)).</span>
<span class="sd">        Only these parameters of a spacecraft are relevant to coverage calculations.</span>
<span class="sd">    </span>
<span class="sd">    :param spc: (Single) spacecraft of which coverage parameters are to be extracted.</span>
<span class="sd">    :paramtype spc: :class:`orbitpy.util.Spacecraft`</span>

<span class="sd">    :return: Tuples with instrument-id, mode-id, scene-field-of-view, field-of-regard and pointing_option(s).</span>
<span class="sd">    :rtype: list, namedtuple, (str or int, str or int, :class:`instrupy.util.ViewGeometry`, &lt;list,:class:`instrupy.util.ViewGeometry`&gt;, &lt;list,:class:`instrupy.util.Orientation`&gt;)</span>

<span class="sd">    .. note::  The field-of-regard parameter and pointing_option parameter are lists in the tuple. </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_p</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;spc_cov_params&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;instru_id&quot;</span><span class="p">,</span> <span class="s2">&quot;mode_id&quot;</span><span class="p">,</span> <span class="s2">&quot;scene_field_of_view&quot;</span><span class="p">,</span> <span class="s2">&quot;field_of_regard&quot;</span><span class="p">,</span> <span class="s2">&quot;pointing_option&quot;</span><span class="p">])</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">spc</span><span class="o">.</span><span class="n">instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">instru</span> <span class="ow">in</span> <span class="n">spc</span><span class="o">.</span><span class="n">instrument</span><span class="p">:</span> <span class="c1"># iterate over each instrument</span>
            <span class="n">instru_id</span> <span class="o">=</span> <span class="n">instru</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">mode_id</span> <span class="ow">in</span> <span class="n">instru</span><span class="o">.</span><span class="n">get_mode_id</span><span class="p">():</span> <span class="c1"># iterate over each mode in the instrument</span>

                <span class="n">scene_field_of_view</span>  <span class="o">=</span> <span class="n">instru</span><span class="o">.</span><span class="n">get_scene_field_of_view</span><span class="p">(</span><span class="n">mode_id</span><span class="p">)</span>
                <span class="n">field_of_regard</span>  <span class="o">=</span> <span class="n">instru</span><span class="o">.</span><span class="n">get_field_of_regard</span><span class="p">(</span><span class="n">mode_id</span><span class="p">)</span> 
                <span class="n">pointing_option</span> <span class="o">=</span> <span class="n">instru</span><span class="o">.</span><span class="n">get_pointing_option</span><span class="p">(</span><span class="n">mode_id</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">field_of_regard</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">[]:</span> <span class="c1"># if FOR is None, use sceneFOV for FOR</span>
                    <span class="n">field_of_regard</span> <span class="o">=</span> <span class="p">[</span><span class="n">instru</span><span class="o">.</span><span class="n">get_scene_field_of_view</span><span class="p">(</span><span class="n">mode_id</span><span class="p">)]</span>
                
                <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_p</span><span class="p">(</span><span class="n">instru_id</span><span class="p">,</span> <span class="n">mode_id</span><span class="p">,</span> <span class="n">scene_field_of_view</span><span class="p">,</span> <span class="n">field_of_regard</span><span class="p">,</span> <span class="n">pointing_option</span><span class="p">))</span>
                    
    <span class="k">return</span> <span class="n">params</span></div>

<span class="k">class</span> <span class="nc">NoInstrument</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="find_in_cov_params_list"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.find_in_cov_params_list.html#orbitpy.coveragecalculator.find_in_cov_params_list">[docs]</a><span class="k">def</span> <span class="nf">find_in_cov_params_list</span><span class="p">(</span><span class="n">cov_param_list</span><span class="p">,</span> <span class="n">instru_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; For an input instrument-id, mode-id, find the corresponding coverage-parameter in an input list of coverage-parameters </span>
<span class="sd">        (list of tuples of (instru_id, mode_id, field-of-view, field-of-regard, pointing_option)). </span>

<span class="sd">    :param cov_param_list: List of tuples of (instrument id, mode id, field-of-view, field-of-regard, pointing_option).</span>
<span class="sd">    :paramtype cov_param_list: list, namedtuple, (str or int, str or int, :class:`instrupy.util.ViewGeometry`, &lt;list, :class:`instrupy.util.ViewGeometry`&gt;, &lt;list,:class:`instrupy.util.Orientation`&gt;)</span>

<span class="sd">    :param instru_id: Instrument identifier. If ``None``, the first tuple in the list of coverage parameters is returned.</span>
<span class="sd">    :paramtype instru_id: str (or) int</span>

<span class="sd">    :param mode_id: Mode identifier. If ``None``, the first tuple in the list of coverage parameters with the matching instru_id is returned.</span>
<span class="sd">    :paramtype mode_id: str (or) int</span>

<span class="sd">    :return: (Single) Tuple of (instrument id, mode id, field-of-view, field-of-regard, pointing-option(s)), such that the instrument-id and </span>
<span class="sd">             the mode-id match the input identifiers (instru_id, mode_id).</span>
<span class="sd">    :rtype: namedtuple, (str or int, str or int, :class:`instrupy.util.ViewGeometry`, &lt;list, :class:`instrupy.util.ViewGeometry`&gt; , &lt;list,:class:`instrupy.util.Orientation`&gt; )</span>

<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">if</span> <span class="n">cov_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cov_param_list</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="k">if</span> <span class="n">instru_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">cov_param_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="n">cov_param_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">instru_id</span> <span class="ow">and</span> <span class="n">mode_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cov_param_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="n">instru_id</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="n">mode_id</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cov_param_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
            
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Entry corresponding to the input instrument-id and mode-id was not found.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NoInstrument</span><span class="p">(</span><span class="s1">&#39;cov_param_list input argument is empty.&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="filter_mid_interval_access"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.filter_mid_interval_access.html#orbitpy.coveragecalculator.filter_mid_interval_access">[docs]</a><span class="k">def</span> <span class="nf">filter_mid_interval_access</span><span class="p">(</span><span class="n">inp_acc_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inp_acc_fl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_acc_fl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Extract the access times at middle of access intervals. The input can be a path to a file or a dataframe. </span>

<span class="sd">        This function can be used for &quot;correction&quot; of access files for purely side-looking instruments with narrow along-track FOV as described below:</span>

<span class="sd">        In case of purely side-looking instruments with narrow-FOV (eg: SARs executing Stripmap operation mode), the access to a grid-point takes place</span>
<span class="sd">        when the grid-point is seen with no squint angle and the access is almost instantaneous (i.e. access duration is very small). </span>
<span class="sd">        The coverage calculations is carried out with the corresponding instrument scene-field-of-view or field-of-regard (built using the scene-filed-of-view) </span>
<span class="sd">        (see :code:`instrupy` package documentation). </span>
<span class="sd">        If the instrument FOV is to be used for coverage calculations, a *very very* small time step-size would need to be used which to impractically long computation time.</span>

<span class="sd">        The access files list rows of access-time, ground-points, and thus independent access opportunities for the instrument</span>
<span class="sd">        when the scene-field-of-view / field-of-regard is used for coverage calculations. </span>
<span class="sd">        If the generated access files from the these coverage calculations of a purely side-looking, narrow along-track FOV instrument is</span>
<span class="sd">        interpreted in the same manner, it would be erroneous.</span>

<span class="sd">        Thus the generated access files are then *corrected* to show access only at approximately (to the nearest propagation time-step) </span>
<span class="sd">        the middle of the access interval. </span>
<span class="sd">        This should be coupled with the required scene-scan-duration (from scene-field-of-view) to get complete information about the access. </span>

<span class="sd">        .. warning:: The correction method is to be used only when the instrument access-duration (determined from the instrument FOV) is smaller </span>
<span class="sd">                     than the propagation time step (determined from the FOR or sceneFOV). </span>

<span class="sd">        :ivar inp_acc_df: Dataframe with the access data which needs to be filtered. The rows correspond to pairs of </span>
<span class="sd">                          access time and corresponding ground-point index. The columns are to be named as: ``time index``, ``GP index``, ``lat [deg]``, ``lon [deg]``.</span>
<span class="sd">                          If ``None``, the ``inp_acc_fl`` input argument must be specified.</span>
<span class="sd">        :vartype inp_acc_df: pd.DataFrame or None</span>

<span class="sd">        :ivar inp_acc_fl: Input access file (filepath with filename). Refer to the ``execute`` method in the ``GridCoverage`` class</span>
<span class="sd">                          for description of the file format. If ``None``, the ``inp_acc_df`` input argument must be specified.</span>
<span class="sd">        :vartype inp_acc_fl: str or None</span>

<span class="sd">        :ivar out_acc_fl: Output access file (filepath with filename). The format is the same as that of the input access file. If ``None`` the file is not written.</span>
<span class="sd">        :vartype out_acc_fl: str or None</span>

<span class="sd">        :returns: Dataframe with the resultant access data.</span>
<span class="sd">        :rtype: pd.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inp_acc_fl</span><span class="p">:</span> <span class="c1"># If input file is specified, the data is taken from it. </span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">inp_acc_fl</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">inp_acc_df</span>

        <span class="n">max_num_acc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">data_indx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_num_acc</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)))</span> <span class="c1"># make a data structure with maximum possible size  </span>

        <span class="k">if</span> <span class="s1">&#39;pnt-opt index&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="p">:</span> <span class="c1"># pointing-options with grid coverage access file</span>
            
            <span class="k">for</span> <span class="n">popt</span><span class="p">,</span> <span class="n">df_per_popt</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;pnt-opt index&#39;</span><span class="p">):</span> <span class="c1"># iterate over each pointing-option</span>

                <span class="c1"># iterate over all the groups (ground-point indices)                </span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df_per_popt</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;GP index&#39;</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">_intv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>            
                    <span class="n">interval_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># add the very first interval start index</span>
                    <span class="n">interval_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_intv</span><span class="p">)</span>
                    <span class="n">interval_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">_intv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">interval_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># add the very last interval end index</span>
                    <span class="n">interval_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="n">mid_points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">interval_indices</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">interval_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="n">mid_points</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mid_points</span><span class="p">]</span>
                    <span class="n">_data</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">mid_points</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">data_indx</span><span class="p">:</span><span class="n">data_indx</span><span class="o">+</span><span class="n">m</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">_data</span>
                    <span class="n">data_indx</span> <span class="o">=</span> <span class="n">data_indx</span> <span class="o">+</span> <span class="n">m</span>
            
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">data_indx</span><span class="p">]</span> <span class="c1"># remove unnecessary rows</span>
        
            <span class="n">out_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span> <span class="s1">&#39;pnt-opt index&#39;</span><span class="p">,</span> <span class="s1">&#39;GP index&#39;</span><span class="p">,</span>  <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>
            <span class="n">out_df</span> <span class="o">=</span> <span class="n">out_df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">&quot;time index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;pnt-opt index&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;GP index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;lat [deg]&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;lon [deg]&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">})</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># grid coverage access file</span>

            <span class="c1"># iterate over all the groups (ground-point indices)            </span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;GP index&#39;</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">_intv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>            
                <span class="n">interval_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># add the very first interval start index</span>
                <span class="n">interval_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_intv</span><span class="p">)</span>
                <span class="n">interval_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">_intv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">interval_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># add the very last interval end index</span>
                <span class="n">interval_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">mid_points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">interval_indices</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">interval_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
                <span class="n">mid_points</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mid_points</span><span class="p">]</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">mid_points</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">data</span><span class="p">[</span><span class="n">data_indx</span><span class="p">:</span><span class="n">data_indx</span><span class="o">+</span><span class="n">m</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">_data</span>
                <span class="n">data_indx</span> <span class="o">=</span> <span class="n">data_indx</span> <span class="o">+</span> <span class="n">m</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">data_indx</span><span class="p">]</span> <span class="c1"># remove unnecessary rows</span>
        
            <span class="n">out_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span> <span class="s1">&#39;GP index&#39;</span><span class="p">,</span> <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>
            <span class="n">out_df</span> <span class="o">=</span> <span class="n">out_df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">&quot;time index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;GP index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;lat [deg]&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;lon [deg]&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">})</span>
        
        <span class="n">out_df</span> <span class="o">=</span> <span class="n">out_df</span><span class="o">.</span><span class="n">round</span><span class="p">({</span><span class="s1">&#39;lat [deg]&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1"># specify round-off</span>
        <span class="n">out_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">out_df</span> <span class="o">=</span> <span class="n">out_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">out_acc_fl</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">inp_acc_fl</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inp_acc_fl</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f1</span><span class="p">:</span>
                    <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="c1"># copy first four header lines from the original access file                  </span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_acc_fl</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">)):</span>
                        <span class="n">f2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                <span class="n">out_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_df</span></div>

<div class="viewcode-block" id="GridCoverage"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.GridCoverage.html#orbitpy.coveragecalculator.GridCoverage">[docs]</a><span class="k">class</span> <span class="nc">GridCoverage</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A coverage calculator class which handles coverage calculation for a spacecraft over a grid. Each ``GridCoverage`` object is specific to </span>
<span class="sd">        a particular grid and spacecraft.</span>

<span class="sd">    :ivar grid: Locations (longitudes, latitudes) (represented by a :class:`orbitpy.util.grid` object) over which coverage calculation is to be performed.</span>
<span class="sd">    :vartype grid: :class:`orbitpy.util.grid`</span>

<span class="sd">    :ivar spacecraft: Spacecraft for which the coverage calculation is performed.</span>
<span class="sd">    :vartype spacecraft: :class:`orbitpy.util.Spacecraft`</span>

<span class="sd">    :ivar state_cart_file: File name with path of the (input) file in which the orbit states in CARTESIAN_EARTH_CENTERED_INERTIAL are available.</span>
<span class="sd">    :vartype state_cart_file: str</span>

<span class="sd">    :ivar cov_params: List of coverage parameters corresponding to all the instruments, modes per instrument in the spacecraft.</span>
<span class="sd">                        Refer to the :class:`orbitpy.coveragecalculator.helper_extract_coverage_parameters_of_spacecraft` function.</span>
<span class="sd">    :vartype cov_params: list, namedtuple</span>

<span class="sd">    :ivar _id: Unique identifier.</span>
<span class="sd">    :vartype _id: str</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GridCoverage.__init__"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.GridCoverage.html#orbitpy.coveragecalculator.GridCoverage.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacecraft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_cart_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Grid</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span> <span class="o">=</span> <span class="n">spacecraft</span> <span class="k">if</span> <span class="n">spacecraft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spacecraft</span><span class="p">,</span> <span class="n">Spacecraft</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">state_cart_file</span><span class="p">)</span> <span class="k">if</span> <span class="n">state_cart_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># Extract the coverage related parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span> <span class="o">=</span> <span class="n">helper_extract_coverage_parameters_of_spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">GridCoverage</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;GRID COVERAGE&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GridCoverage.from_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.GridCoverage.html#orbitpy.coveragecalculator.GridCoverage.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Parses an ``GridCoverage`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the GRID COVERAGE specifications.</span>

<span class="sd">                Following keys are to be specified.</span>
<span class="sd">                </span>
<span class="sd">                * &quot;grid&quot;:                  (dict) Refer to :class:`orbitpy.grid.Grid.from_dict`</span>
<span class="sd">                * &quot;spacecraft&quot;:            (dict) Refer to :class:`orbitpy.util.Spacecraft.from_dict`</span>
<span class="sd">                * &quot;cartesianStateFilePath&quot;: (str) File path (with file name) to the file with the propagated spacecraft states. The states must be in </span>
<span class="sd">                                             CARTESIAN_EARTH_CENTERED_INERTIAL. Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the data format.</span>
<span class="sd">                * &quot;@id&quot;:                    (str or int) Unique identifier of the coverage calculator object.</span>

<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``GridCoverage`` object.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.GridCoverage`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">spc_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spacecraft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GridCoverage</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">grid_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">spacecraft</span> <span class="o">=</span> <span class="n">Spacecraft</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">spc_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">spc_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">state_cart_file</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cartesianStateFilePath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                            <span class="n">_id</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;@id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>

<div class="viewcode-block" id="GridCoverage.to_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.GridCoverage.html#orbitpy.coveragecalculator.GridCoverage.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the GridCoverage object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``GridCoverage`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;@type&quot;</span><span class="p">:</span> <span class="s2">&quot;GRID COVERAGE&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;grid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                     <span class="s2">&quot;spacecraft&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                     <span class="s2">&quot;cartesianStateFilePath&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                     <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;GridCoverage.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

<div class="viewcode-block" id="GridCoverage.execute"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.GridCoverage.html#orbitpy.coveragecalculator.GridCoverage.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instru_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_field_of_regard</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_file_access</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mid_access_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;DirectSphericalPIP&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform orbit coverage calculation for a specific instrument and mode of the instrument in the object instance. Coverage is calculated for the period over which the </span>
<span class="sd">            input spacecraft propagated states are available. The time-resolution of the coverage calculation is the </span>
<span class="sd">            same as the time resolution at which the spacecraft states are available. Note that the sceneFOV of an instrument (which may be the same as the instrument FOV)</span>
<span class="sd">            is used for coverage calculations unless it has been specified to use the field-of-regard.</span>

<span class="sd">        :param instru_id: Instrument identifier (must be present in the input spacecraft). If ``None``, the first instrument in the spacecraft&#39;s list of instruments is considered.</span>
<span class="sd">        :paramtype instru_id: str (or) int</span>

<span class="sd">        :param mode_id: Mode identifier (corresponding to the input instrument (id)). If ``None``, the first mode of the instrument is considered.</span>
<span class="sd">        :paramtype mode_id: str (or) int</span>

<span class="sd">        :param use_field_of_regard: This is a boolean flag to specify if the the field-of-regard is to be considered for the coverage calculations. </span>
<span class="sd">                                    Default value is ``False`` (i.e. the scene-field-of-view will be considered in the coverage calculations).</span>
<span class="sd">        :paramtype use_field_of_regard: bool</span>

<span class="sd">        :param out_file_access: File name with path of the file in which the access data is written.</span>
<span class="sd">                </span>
<span class="sd">                The file format is as follows:</span>

<span class="sd">                *  The first row contains the coverage calculation type.</span>
<span class="sd">                *  The second row containing the mission epoch in Julian Day UT1. The time (index) in the state data is referenced to this epoch.</span>
<span class="sd">                *  The third row contains the time-step size in seconds. </span>
<span class="sd">                *  The fourth row contains the duration (in days) for which coverage calculation is executed.</span>
<span class="sd">                *  The fifth row contains the columns headers and the sixth row onwards contains the corresponding data. </span>

<span class="sd">                Note that time associated with a row is:  ``time = epoch (in JDUT1) + time-index * time-step-size (in secs) * (1/86400)`` </span>

<span class="sd">                Description of the coverage data is given below:</span>

<span class="sd">                .. csv-table:: Coverage data description</span>
<span class="sd">                    :header: Column, Data type, Units, Description</span>
<span class="sd">                    :widths: 10,10,10,30</span>

<span class="sd">                    time index, int, , Access time-index.</span>
<span class="sd">                    GP index, int, , Grid-point index.</span>
<span class="sd">                    lat [deg], float, degrees, Latitude corresponding to the GP index.</span>
<span class="sd">                    lon [deg], float, degrees, Longitude corresponding to the GP index.</span>

<span class="sd">        :paramtype out_file_access: str</span>

<span class="sd">        :param mid_access_only: Flag to indicate if the coverage data is to be processed to indicate only the access at the middle of an (continuous) access-interval. </span>
<span class="sd">                                Default value is ``False``.</span>
<span class="sd">        :paramtype mid_access_only: bool</span>

<span class="sd">        :param method:  Indicate the coverage method (relevant for the case of sensor FOVs described by spherical-polygon vertices and Rectangular FOV).</span>
<span class="sd">                        Only entries `DirectSphericalPIP` or `ProjectedPIP` or `RectangularPIP` are allowed. </span>
<span class="sd">                        Default method is `DirectSphericalPIP`.</span>

<span class="sd">                        The `DirectSphericalPIP` method corresponds to implementation of the `propcov.DSPIPCustomSensor` class, while</span>
<span class="sd">                        the `ProjectedPIP` corresponds to the implementation of the `propcov.GMATCustomSensor` class.                        </span>
<span class="sd">                        </span>
<span class="sd">                        For details on the `DirectSphericalPIP` method please refer to the article: R. Ketzner, V. Ravindra and M. Bramble, </span>
<span class="sd">                        &#39;A Robust, Fast, and Accurate Algorithm for Point in Spherical Polygon Classification with Applications in Geoscience and Remote Sensing&#39;, Computers and Geosciences, accepted.</span>
<span class="sd">                        </span>
<span class="sd">                        In the above article, the algorithm is described and compared to the GMAT CustomSensor algorithm which is the same as the </span>
<span class="sd">                        point-in-polygon algorithm implemented in the `propcov.GMATCustomSensor` class. </span>
<span class="sd">                        Compared to the `propcov.GMATCustomSensor` class, the `propcov.DSPIPCustomSensor` has been shown to yield improvement in runtime </span>
<span class="sd">                        and also to be more accurate.</span>

<span class="sd">                        `RectangularPIP` method is applicable only for RECTANGULAR spherical geometry shapes. It is based on the</span>
<span class="sd">                        `propcov.RectangularSensor` class. The class evaluates the dot product between the target point and the normal of the hemispherical-planes</span>
<span class="sd">                        formed by the 4 edges of the rectangle shape (on spherical surface). The corners of the rectangle are arranged in anti-clockwise manner about the center on the spherical surface,</span>
<span class="sd">                        if the target point is in the Northern hemisphere corresponding to 4 hemispherical planes formed by the edges of the rectangle, then the target falls</span>
<span class="sd">                        within the sensor FOV.  </span>
<span class="sd"> </span>
<span class="sd">        :paramtype method: str</span>

<span class="sd">        :return: Coverage output info.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.CoverageOutputInfo`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###### read in the propagated states and auxillary information ######               </span>
        <span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="o">=</span> <span class="n">orbitpy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">extract_auxillary_info_from_state_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">)</span>
        <span class="n">states_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1">###### Prepare output file in which results shall be written ######</span>
        <span class="n">access_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file_access</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">access_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">access_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;GRID COVERAGE&quot;</span><span class="p">])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Epoch [JDUT1] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Step size [s] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step_size</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Mission Duration [Days] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span><span class="s1">&#39;GP index&#39;</span><span class="p">,</span> <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>
        
        <span class="c1">###### find the FOV/ FOR corresponding to the input sensor-id, mode-id  ######</span>
        <span class="n">cov_param</span><span class="o">=</span> <span class="n">find_in_cov_params_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">instru_id</span><span class="p">,</span> <span class="n">mode_id</span><span class="p">)</span>
        <span class="c1">#print(&quot;cov_param &quot;, cov_param)</span>
        <span class="c1"># the input instru_id, mode_id may be None, so get the sensor, mode ids.</span>
        <span class="n">instru_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">instru_id</span>
        <span class="n">mode_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">mode_id</span>

        <span class="k">if</span> <span class="n">use_field_of_regard</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">view_geom</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">field_of_regard</span> <span class="c1"># a list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">view_geom</span> <span class="o">=</span> <span class="p">[</span><span class="n">cov_param</span><span class="o">.</span><span class="n">scene_field_of_view</span><span class="p">]</span> <span class="c1"># make into list </span>
            
        
        <span class="c1">#print(&quot;view_geom &quot;, view_geom)</span>
        <span class="c1">###### iterate and calculate coverage seperately for each view_geom element. TODO: Streamline this behavior ######</span>
        <span class="k">for</span> <span class="n">__view_geom</span> <span class="ow">in</span> <span class="n">view_geom</span><span class="p">:</span>
            
            <span class="c1">###### form the propcov.Spacecraft object ######</span>
            <span class="n">attitude</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">NadirPointingAttitude</span><span class="p">()</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">LagrangeInterpolator</span><span class="p">()</span>

            <span class="n">spc</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">orbitState</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">orbitState</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">attitude</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="c1"># orient the spacecraft-bus</span>
            <span class="n">spc_orien</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">spacecraftBus</span><span class="o">.</span><span class="n">orientation</span>
            <span class="k">if</span> <span class="n">spc_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span><span class="p">:</span>            
                <span class="n">spc</span><span class="o">.</span><span class="n">SetBodyNadirOffsetAngles</span><span class="p">(</span><span class="n">angle1</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span> <span class="c1"># input angles are in degrees</span>
                                            <span class="n">seq1</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="n">seq3</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="c1"># only NADIR_POINTING reference frame is supported.           </span>

            <span class="c1">###### build the sensor object ######</span>
            <span class="n">sen_sph_geom</span> <span class="o">=</span> <span class="n">__view_geom</span><span class="o">.</span><span class="n">sph_geom</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">):</span>
                <span class="n">sensor</span><span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">ConicalSensor</span><span class="p">(</span><span class="n">halfAngle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">diameter</span><span class="p">))</span> <span class="c1"># input angle in radians</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span> <span class="ow">or</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;DirectSphericalPIP&#39;</span><span class="p">:</span>
                    <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">DSPIPCustomSensor</span><span class="p">(</span> <span class="n">coneAngleVecIn</span>    <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">cone_angle_vec</span>   <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>  <span class="c1"># input angle in radians  </span>
                                                <span class="n">clockAngleVecIn</span>   <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">clock_angle_vec</span>  <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>
                                                <span class="n">contained</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>  
                                                <span class="p">)</span>
                
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;ProjectedPIP&#39;</span><span class="p">:</span>
                    <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">GMATCustomSensor</span><span class="p">(</span> <span class="n">coneAngleVecIn</span>    <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">cone_angle_vec</span>   <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>  <span class="c1"># input angle in radians  </span>
                                                <span class="n">clockAngleVecIn</span>   <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">clock_angle_vec</span>  <span class="p">)</span>   <span class="p">)</span>   <span class="p">)</span>   
                                                <span class="p">)</span>
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;RectangularPIP&#39;</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">angleHeightIn</span><span class="p">,</span> <span class="n">angleWidthIn</span><span class="p">]</span> <span class="o">=</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">get_fov_height_and_width</span><span class="p">()</span>
                    <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">RectangularSensor</span><span class="p">(</span> <span class="n">angleHeightIn</span>    <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">angleHeightIn</span> <span class="p">)</span> <span class="p">,</span>  <span class="c1"># input angle in radians  </span>
                                                        <span class="n">angleWidthIn</span>   <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">angleWidthIn</span> <span class="p">)</span>   
                                                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please specify a valid coverage method.&quot;</span><span class="p">)</span>         
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid sensor spherical geometry shape.&quot;</span><span class="p">)</span>

            <span class="n">sen_orien</span> <span class="o">=</span> <span class="n">__view_geom</span><span class="o">.</span><span class="n">orien</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">SC_BODY_FIXED</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span> <span class="ow">and</span> <span class="n">spc_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span><span class="p">):</span> <span class="c1"># The second condition is equivalent of orienting sensor w.r.t spacecraft body when the spacecraft body is aligned to nadir-frame</span>
                <span class="n">sensor</span><span class="o">.</span><span class="n">SetSensorBodyOffsetAngles</span><span class="p">(</span><span class="n">angle1</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span> <span class="c1"># input angles are in degrees</span>
                                                 <span class="n">seq1</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="n">seq3</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            
            <span class="c1">###### attach the sensor ######</span>
            <span class="n">spc</span><span class="o">.</span><span class="n">AddSensor</span><span class="p">(</span><span class="n">sensor</span><span class="p">)</span>
            <span class="c1">###### make propcov coverage checker object ######</span>
            <span class="n">cov_checker</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">CoverageChecker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">point_group</span><span class="p">,</span> <span class="n">spc</span><span class="p">)</span>
            <span class="c1">###### iterate over the propagated states ######</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">AbsoluteDate</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">])</span>
                <span class="n">jd_date</span> <span class="o">=</span> <span class="n">epoch_JDUT1</span> <span class="o">+</span> <span class="n">time_index</span><span class="o">*</span><span class="n">step_size</span><span class="o">*</span><span class="n">DAYS_PER_SEC</span>
                <span class="n">date</span><span class="o">.</span><span class="n">SetJulianDate</span><span class="p">(</span><span class="n">jd_date</span><span class="p">)</span>
                
                <span class="n">cart_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;x [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;y [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;z [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vx [km/s]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vy [km/s]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vz [km/s]&#39;</span><span class="p">]]</span>
                <span class="n">spc</span><span class="o">.</span><span class="n">SetOrbitEpochOrbitStateCartesian</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector6</span><span class="p">(</span><span class="n">cart_state</span><span class="p">))</span>
                
                <span class="c1"># compute coverage</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">cov_checker</span><span class="o">.</span><span class="n">CheckPointCoverage</span><span class="p">()</span> <span class="c1"># list of indices of the GPs accessed shall be returned</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#If no ground-points are accessed at this time, skip writing the row altogether.</span>
                    <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get_lat_lon_from_index</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
                        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">time_index</span><span class="p">,</span> <span class="n">pnt</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">longitude</span><span class="p">])</span>

        <span class="c1">##### Close file #####                </span>
        <span class="n">access_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1">##### filter mid-interval access data if necessary #####</span>
        <span class="k">if</span> <span class="n">mid_access_only</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">filter_mid_interval_access</span><span class="p">(</span><span class="n">inp_acc_fl</span><span class="o">=</span><span class="n">out_file_access</span><span class="p">,</span> <span class="n">out_acc_fl</span><span class="o">=</span><span class="n">out_file_access</span><span class="p">)</span>        
        
        <span class="k">return</span> <span class="n">CoverageOutputInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span>   <span class="s2">&quot;coverageType&quot;</span><span class="p">:</span> <span class="s2">&quot;GRID COVERAGE&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;spacecraftId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span>
                                                <span class="s2">&quot;instruId&quot;</span><span class="p">:</span> <span class="n">instru_id</span><span class="p">,</span>
                                                <span class="s2">&quot;modeId&quot;</span><span class="p">:</span> <span class="n">mode_id</span><span class="p">,</span>
                                                <span class="s2">&quot;usedFieldOfRegard&quot;</span><span class="p">:</span> <span class="n">use_field_of_regard</span><span class="p">,</span>
                                                <span class="s2">&quot;filterMidIntervalAccess&quot;</span><span class="p">:</span> <span class="n">mid_access_only</span><span class="p">,</span>
                                                <span class="s2">&quot;gridId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span>
                                                <span class="s2">&quot;stateCartFile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                                                <span class="s2">&quot;accessFile&quot;</span><span class="p">:</span> <span class="n">out_file_access</span><span class="p">,</span>
                                                <span class="s2">&quot;startDate&quot;</span><span class="p">:</span> <span class="n">epoch_JDUT1</span><span class="p">,</span>
                                                <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
                                                <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span></div></div>
            
<div class="viewcode-block" id="PointingOptionsCoverage"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsCoverage.html#orbitpy.coveragecalculator.PointingOptionsCoverage">[docs]</a><span class="k">class</span> <span class="nc">PointingOptionsCoverage</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A coverage calculator which handles coverage calculation for an instrument (on a spacecraft) with a set of pointing-options.</span>
<span class="sd">       A pointing-option refers to orientation of the instrument in the NADIR_POINTING frame. The set of pointing-options </span>
<span class="sd">       represent all the possible orientations of the instrument due to maneuverability of the instrument and/or satellite-bus.</span>
<span class="sd">       The ground-locations for each pointing-option, at each propagation time-step is calculated as the coverage result.      </span>

<span class="sd">    :ivar spacecraft: Spacecraft for which the coverage calculation is performed. The pointing options are included in the instrument definitions of the spacecraft. </span>
<span class="sd">    :vartype spacecraft: :class:`orbitpy.util.Spacecraft`</span>

<span class="sd">    :ivar state_cart_file: File name with path of the (input) file in which the orbit states in CARTESIAN_EARTH_CENTERED_INERTIAL are available.</span>
<span class="sd">                           Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the file data format.</span>
<span class="sd">    :vartype state_cart_file: str</span>

<span class="sd">    :ivar cov_params: List of coverage parameters corresponding to all the instruments, modes per instrument in the spacecraft.</span>
<span class="sd">                        Refer to the :class:`orbitpy.coveragecalculator.helper_extract_coverage_parameters_of_spacecraft` function.</span>
<span class="sd">    :vartype cov_params: list, namedtuple</span>

<span class="sd">    :ivar _id: Unique identifier.</span>
<span class="sd">    :vartype _id: str</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PointingOptionsCoverage.__init__"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsCoverage.html#orbitpy.coveragecalculator.PointingOptionsCoverage.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spacecraft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_cart_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span> <span class="o">=</span> <span class="n">spacecraft</span> <span class="k">if</span> <span class="n">spacecraft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spacecraft</span><span class="p">,</span> <span class="n">Spacecraft</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">state_cart_file</span><span class="p">)</span> <span class="k">if</span> <span class="n">state_cart_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># Extract the coverage related parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span> <span class="o">=</span> <span class="n">helper_extract_coverage_parameters_of_spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PointingOptionsCoverage</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;POINTING OPTIONS COVERAGE&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PointingOptionsCoverage.from_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsCoverage.html#orbitpy.coveragecalculator.PointingOptionsCoverage.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Parses an ``PointingOptionsCoverage`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the GridCoverage specifications.</span>

<span class="sd">                Following keys are to be specified.</span>
<span class="sd">                </span>
<span class="sd">                * &quot;spacecraft&quot;:             (dict) Refer to :class:`orbitpy.util.Spacecraft.from_dict`</span>
<span class="sd">                * &quot;cartesianStateFilePath&quot;: (str) File path (with file name) to the file with the propagated spacecraft states. The states must be in </span>
<span class="sd">                                             CARTESIAN_EARTH_CENTERED_INERTIAL. Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the data format.</span>
<span class="sd">                * &quot;@id&quot;:                    (str or int) Unique identifier of the coverage calculator object.</span>

<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``PointingOptionsCoverage`` object.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.PointingOptionsCoverage`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spc_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spacecraft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PointingOptionsCoverage</span><span class="p">(</span><span class="n">spacecraft</span> <span class="o">=</span> <span class="n">Spacecraft</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">spc_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">spc_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                                       <span class="n">state_cart_file</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cartesianStateFilePath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                            <span class="n">_id</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;@id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="PointingOptionsCoverage.to_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsCoverage.html#orbitpy.coveragecalculator.PointingOptionsCoverage.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the PointingOptionsCoverage object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``PointingOptionsCoverage`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;@type&quot;</span><span class="p">:</span> <span class="s2">&quot;POINTING OPTIONS COVERAGE&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;spacecraft&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                     <span class="s2">&quot;cartesianStateFilePath&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                     <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;PointingOptionsCoverage.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

<div class="viewcode-block" id="PointingOptionsCoverage.intersect_vector_sphere"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsCoverage.html#orbitpy.coveragecalculator.PointingOptionsCoverage.intersect_vector_sphere">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">intersect_vector_sphere</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">vec_direc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  Find intersection of an input vector with a sphere. The origin of the reference-frame (in which the input vector is expressed)</span>
<span class="sd">             is assumed to be at the center of the sphere.</span>
<span class="sd">             https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection  </span>
<span class="sd">        </span>
<span class="sd">        :param r: Radius of sphere.</span>
<span class="sd">        :paramtype r: float</span>

<span class="sd">        :param o: Cartesian coordinates of the start position of the vector.</span>
<span class="sd">        :paramtype o: list, float</span>

<span class="sd">        :param vec_direc: Direction of the vector.</span>
<span class="sd">        :paramtype vec_direc: list, float</span>

<span class="sd">        :return: Cartesian coordinates of the intersection point if valid intersection, else ``False`` to indicate no intersection.</span>
<span class="sd">        :rtype: list, float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">vec_direc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec_direc</span><span class="p">)</span>
        <span class="c1"># normalize direction vector        </span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_direc</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Encountered division by zero in vector normalization function.&quot;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">vec_direc</span><span class="o">/</span><span class="n">norm</span> 

        <span class="n">under_root</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">under_root</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">under_root</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">under_root</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">):</span> <span class="c1"># find the point closest to the sphere wrt the vector origin</span>
                <span class="n">intersect_point</span> <span class="o">=</span> <span class="n">o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">d1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intersect_point</span> <span class="o">=</span> <span class="n">o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">d2</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">under_root</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">o</span><span class="p">)</span>
            <span class="n">intersect_point</span> <span class="o">=</span> <span class="n">o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">return</span> <span class="n">intersect_point</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="PointingOptionsCoverage.execute"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsCoverage.html#orbitpy.coveragecalculator.PointingOptionsCoverage.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instru_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_file_access</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform coverage calculation for a specific instrument and mode. Coverage is calculated for the period over which the </span>
<span class="sd">            input spacecraft propagated states are available. The time-resolution of the coverage calculation is the </span>
<span class="sd">            same as the time resolution at which the spacecraft states are available.</span>

<span class="sd">        :param instru_id: Sensor identifier (corresponding to the input spacecraft). If ``None``, the first sensor in the spacecraft list of sensors is considered.</span>
<span class="sd">        :paramtype instru_id: str (or) int</span>

<span class="sd">        :param mode_id: Mode identifier (corresponding to the input sensor (id) and spacecraft). If ``None``, the first mode of the corresponding input sensor of the spacecraft is considered.</span>
<span class="sd">        :paramtype mode_id: str (or) int        </span>

<span class="sd">        :param out_file_access: File name with path of the file in which the access data is written.</span>
<span class="sd">                </span>
<span class="sd">                The format of the output data file is as follows:</span>

<span class="sd">                *  The first row contains the coverage calculation type.</span>
<span class="sd">                *  The second row containing the mission epoch in Julian Day UT1. The time (index) in the state data is referenced to this epoch.</span>
<span class="sd">                *  The third row contains the time-step size in seconds. </span>
<span class="sd">                *  The fourth row contains the duration (in days) for which coverage calculation is executed.</span>
<span class="sd">                *  The fifth row contains the columns headers and the sixth row onwards contains the corresponding data. </span>

<span class="sd">                Note that time associated with a row is:  ``time = epoch (in JDUT1) + time-index * time-step-size (in secs) * (1/86400)`` </span>

<span class="sd">                Description of the coverage data is given below:</span>

<span class="sd">                .. csv-table:: Coverage data description</span>
<span class="sd">                    :header: Column, Data type, Units, Description</span>
<span class="sd">                    :widths: 10,10,10,30</span>

<span class="sd">                    time index, int, , Access time-index.</span>
<span class="sd">                    pnt-opt index, int, , &quot;Pointing options index. The indexing starts from 0, where 0 is the first pointing-option in the list of instrument pointing-options.&quot;</span>
<span class="sd">                    lat [deg], float, degrees, Latitude of accessed ground-location.</span>
<span class="sd">                    lon [deg], float, degrees, Longitude of accessed ground-location.</span>
<span class="sd">        </span>
<span class="sd">        :paramtype out_file_access: str</span>

<span class="sd">        :return: Coverage output info.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.CoverageOutputInfo`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###### read in the propagated states and auxillary information ######               </span>
        <span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="o">=</span> <span class="n">orbitpy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">extract_auxillary_info_from_state_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">)</span>
        <span class="n">states_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">earth</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Earth</span><span class="p">()</span>

        <span class="c1">###### Prepare output file in which results shall be written ######</span>
        <span class="n">access_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file_access</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">access_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">access_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;POINTING OPTIONS COVERAGE&quot;</span><span class="p">])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Epoch [JDUT1] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Step size [s] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step_size</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Mission Duration [Days] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span> <span class="s1">&#39;pnt-opt index&#39;</span><span class="p">,</span> <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>
        
        <span class="c1">###### find the pointing-options corresponding to the input sensor-id, mode-id  ######</span>
        <span class="n">cov_param</span> <span class="o">=</span> <span class="n">find_in_cov_params_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">instru_id</span><span class="p">,</span> <span class="n">mode_id</span><span class="p">)</span>
        <span class="n">pointing_option</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">pointing_option</span>
        <span class="k">if</span> <span class="n">pointing_option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No pointing options specified for the particular sensor, mode. Exiting PointingOptionsCoverage.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># the input instru_id, mode_id may be None, so get the sensor, mode ids.</span>
        <span class="n">instru_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">instru_id</span>
        <span class="n">mode_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">mode_id</span>
        <span class="c1">###### iterate over the propagated states ######</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">AbsoluteDate</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">])</span>
            <span class="n">jd_date</span> <span class="o">=</span> <span class="n">epoch_JDUT1</span> <span class="o">+</span> <span class="n">time_index</span><span class="o">*</span><span class="n">step_size</span><span class="o">*</span><span class="n">DAYS_PER_SEC</span>
            <span class="n">date</span><span class="o">.</span><span class="n">SetJulianDate</span><span class="p">(</span><span class="n">jd_date</span><span class="p">)</span>
            
            <span class="n">cart_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;x [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;y [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;z [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vx [km/s]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vy [km/s]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vz [km/s]&#39;</span><span class="p">]]</span>
            <span class="n">orbit_state</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">OrbitState</span><span class="o">.</span><span class="n">fromCartesianState</span><span class="p">(</span><span class="n">propcov</span><span class="o">.</span><span class="n">Rvector6</span><span class="p">(</span><span class="n">cart_state</span><span class="p">))</span>
            
            <span class="c1"># iterate over all pointing options</span>
            <span class="k">if</span> <span class="n">pointing_option</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pnt_opt_idx</span><span class="p">,</span> <span class="n">pnt_opt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pointing_option</span><span class="p">):</span> <span class="c1"># note that the pointing-option is indexed from 0 onwards</span>
                    <span class="c1">###### form the propcov.Spacecraft object ######</span>
                    <span class="n">attitude</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">NadirPointingAttitude</span><span class="p">()</span>
                    <span class="n">interp</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">LagrangeInterpolator</span><span class="p">()</span>

                    <span class="n">spc</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Spacecraft</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">orbit_state</span><span class="p">,</span> <span class="n">attitude</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

                    <span class="c1"># orient the spacecraft-bus according to the pointing-option. Assumed that the instrument-pointing axis is aligned to the spacecraft-bus z-axis.</span>
                    <span class="k">if</span> <span class="n">pnt_opt</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span><span class="p">:</span>            
                        <span class="n">spc</span><span class="o">.</span><span class="n">SetBodyNadirOffsetAngles</span><span class="p">(</span><span class="n">angle1</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span> <span class="c1"># input angles are in degrees</span>
                                                    <span class="n">seq1</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="n">seq3</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>            
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="c1"># only NADIR_POINTING reference frame is supported.</span>
                    
                    <span class="n">rot_N2B</span> <span class="o">=</span> <span class="n">spc</span><span class="o">.</span><span class="n">GetNadirToBodyMatrix</span><span class="p">()</span>
                    <span class="n">earth_fixed_state</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">GetBodyFixedState</span><span class="p">(</span><span class="n">propcov</span><span class="o">.</span><span class="n">Rvector6</span><span class="p">(</span><span class="n">cart_state</span><span class="p">),</span> <span class="n">jd_date</span><span class="p">)</span>
                    <span class="n">rot_EF2N</span> <span class="o">=</span> <span class="n">spc</span><span class="o">.</span><span class="n">GetBodyFixedToReference</span><span class="p">(</span><span class="n">earth_fixed_state</span><span class="p">)</span> <span class="c1"># Earth fixed to Nadir</span>
                    <span class="n">rot_EF2B</span> <span class="o">=</span> <span class="n">rot_N2B</span> <span class="o">*</span> <span class="n">rot_EF2N</span>
                    <span class="c1"># find the direction of the pointing axis (z-axis of the satellite body) in the Earth-Fixed frame                </span>
                    <span class="n">pnt_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">rot_EF2B</span><span class="o">.</span><span class="n">GetElement</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">rot_EF2B</span><span class="o">.</span><span class="n">GetElement</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">rot_EF2B</span><span class="o">.</span><span class="n">GetElement</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span> <span class="c1"># Equivalent to pnt_axis = R_EF2B.Transpose() * Rvector3(0,0,1)</span>
                    <span class="n">earth_fixed_state</span> <span class="o">=</span> <span class="n">earth_fixed_state</span><span class="o">.</span><span class="n">GetRealArray</span><span class="p">()</span>
                    <span class="n">earth_fixed_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">earth_fixed_state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">earth_fixed_state</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">earth_fixed_state</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

                    <span class="n">intersect_point</span> <span class="o">=</span> <span class="n">PointingOptionsCoverage</span><span class="o">.</span><span class="n">intersect_vector_sphere</span><span class="p">(</span><span class="n">earth</span><span class="o">.</span><span class="n">GetRadius</span><span class="p">(),</span> <span class="n">earth_fixed_pos</span><span class="p">,</span> <span class="n">pnt_axis</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">intersect_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">geo_coords</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">Convert</span><span class="p">(</span><span class="n">propcov</span><span class="o">.</span><span class="n">Rvector3</span><span class="p">(</span><span class="n">intersect_point</span><span class="p">),</span> <span class="s2">&quot;Cartesian&quot;</span><span class="p">,</span> <span class="s2">&quot;Spherical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">GetRealArray</span><span class="p">()</span> <span class="c1"># intersect_point is in Earth Fixed coords so can be converted.</span>
                        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">time_index</span><span class="p">,</span> <span class="n">pnt_opt_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">geo_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">geo_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">3</span><span class="p">)])</span>

        <span class="c1">##### Close file #####                </span>
        <span class="n">access_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">CoverageOutputInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span>   <span class="s2">&quot;coverageType&quot;</span><span class="p">:</span> <span class="s2">&quot;POINTING OPTIONS COVERAGE&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;spacecraftId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span>
                                                <span class="s2">&quot;instruId&quot;</span><span class="p">:</span> <span class="n">instru_id</span><span class="p">,</span>
                                                <span class="s2">&quot;modeId&quot;</span><span class="p">:</span> <span class="n">mode_id</span><span class="p">,</span>
                                                <span class="s2">&quot;usedFieldOfRegard&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;filterMidIntervalAccess&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;gridId&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;stateCartFile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                                                <span class="s2">&quot;accessFile&quot;</span><span class="p">:</span> <span class="n">out_file_access</span><span class="p">,</span>
                                                <span class="s2">&quot;startDate&quot;</span><span class="p">:</span> <span class="n">epoch_JDUT1</span><span class="p">,</span>
                                                <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
                                                <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span></div></div>

<div class="viewcode-block" id="PointingOptionsWithGridCoverage"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.html#orbitpy.coveragecalculator.PointingOptionsWithGridCoverage">[docs]</a><span class="k">class</span> <span class="nc">PointingOptionsWithGridCoverage</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A coverage calculator which handles coverage calculation for a spacecraft over a grid for a set of pointing-options (of an instrument (on a spacecraft)).   </span>
<span class="sd">        A pointing-option refers to orientation of the instrument in the NADIR_POINTING frame. Set of pointing-options </span>
<span class="sd">        represent all the possible orientations of the instrument due to maneuverability of the instrument and/or satellite-bus.</span>
<span class="sd">        Access opportunities (set of access-time, grid-point) is calculated seperately for each pointing-option at each propagation time-step.</span>
<span class="sd">        Each coverage object is specific to a particular grid and spacecraft. </span>

<span class="sd">    :ivar grid: Locations (longitudes, latitudes) over which coverage calculation is to be performed.</span>
<span class="sd">    :vartype grid: :class:`orbitpy.util.grid`</span>

<span class="sd">    :ivar spacecraft: Spacecraft for which the coverage calculation is performed.</span>
<span class="sd">    :vartype spacecraft: :class:`orbitpy.util.Spacecraft`</span>

<span class="sd">    :ivar state_cart_file: File name with path of the (input) file in which the orbit states in CARTESIAN_EARTH_CENTERED_INERTIAL are available.</span>
<span class="sd">                           Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the file data format.</span>
<span class="sd">    :vartype state_cart_file: str</span>

<span class="sd">    :ivar cov_params: List of coverage parameters corresponding to all the instruments, modes per instrument in the spacecraft.</span>
<span class="sd">                        Refer to the :class:`orbitpy.coveragecalculator.helper_extract_coverage_parameters_of_spacecraft` function.</span>
<span class="sd">    :vartype cov_params: list, namedtuple</span>

<span class="sd">    :ivar _id: Unique identifier.</span>
<span class="sd">    :vartype _id: str</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PointingOptionsWithGridCoverage.__init__"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.html#orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacecraft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_cart_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Grid</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span> <span class="o">=</span> <span class="n">spacecraft</span> <span class="k">if</span> <span class="n">spacecraft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spacecraft</span><span class="p">,</span> <span class="n">Spacecraft</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">state_cart_file</span><span class="p">)</span> <span class="k">if</span> <span class="n">state_cart_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># Extract the coverage related parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span> <span class="o">=</span> <span class="n">helper_extract_coverage_parameters_of_spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PointingOptionsWithGridCoverage</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;POINTING OPTIONS WITH GRID COVERAGE&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PointingOptionsWithGridCoverage.from_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.html#orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Parses an ``PointingOptionsWithGridCoverage`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the PointingOptionsWithGridCoverage specifications.</span>

<span class="sd">                Following keys are to be specified.</span>
<span class="sd">                </span>
<span class="sd">                * &quot;grid&quot;:                  (dict) Refer to :class:`orbitpy.grid.Grid.from_dict`</span>
<span class="sd">                * &quot;spacecraft&quot;:            (dict) Refer to :class:`orbitpy.util.Spacecraft.from_dict`</span>
<span class="sd">                * &quot;cartesianStateFilePath&quot;: (str) File path (with file name) to the file with the propagated spacecraft states. The states must be in </span>
<span class="sd">                                             CARTESIAN_EARTH_CENTERED_INERTIAL. Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the data format.</span>
<span class="sd">                * &quot;@id&quot;:                    (str or int) Unique identifier of the coverage calculator object.</span>

<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``PointingOptionsWithGridCoverage`` object.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.PointingOptionsWithGridCoverage`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">spc_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spacecraft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PointingOptionsWithGridCoverage</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">grid_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                                               <span class="n">spacecraft</span> <span class="o">=</span> <span class="n">Spacecraft</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">spc_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">spc_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                                               <span class="n">state_cart_file</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cartesianStateFilePath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                               <span class="n">_id</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;@id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>

<div class="viewcode-block" id="PointingOptionsWithGridCoverage.to_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.html#orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the GridCoverage object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``PointingOptionsWithGridCoverage`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;@type&quot;</span><span class="p">:</span> <span class="s2">&quot;POINTING OPTIONS WITH GRID COVERAGE&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;grid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                     <span class="s2">&quot;spacecraft&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                     <span class="s2">&quot;cartesianStateFilePath&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                     <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;PointingOptionsWithGridCoverage.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

<div class="viewcode-block" id="PointingOptionsWithGridCoverage.execute"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.html#orbitpy.coveragecalculator.PointingOptionsWithGridCoverage.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instru_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_file_access</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mid_access_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;DirectSphericalPIP&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform orbit coverage calculation for a specific instrument and mode. </span>
<span class="sd">            The scene-field-of-view of the instrument is considered (no scope to use field-of-regard) in the coverage calculation. </span>
<span class="sd">            Coverage is calculated for the period over which the input spacecraft propagated states are available. </span>
<span class="sd">            The time-resolution of the coverage calculation is the same as the time resolution at which the spacecraft states are available.</span>
<span class="sd">            The access-times, grid-points are calculated seperately for each pointing-option.</span>
<span class="sd">            Note that the sceneFOV of an instrument (which may be the same as the instrument FOV) is used for coverage calculations.</span>

<span class="sd">        :param instru_id: Sensor identifier (corresponding to the input spacecraft). If ``None``, the first sensor in the spacecraft list of sensors is considered.</span>
<span class="sd">        :paramtype instru_id: str (or) int</span>

<span class="sd">        :param mode_id: Mode identifier (corresponding to the input sensor (id) and spacecraft). If ``None``, the first mode of the corresponding input sensor of the spacecraft is considered.</span>
<span class="sd">        :paramtype mode_id: str (or) int</span>

<span class="sd">        :param out_file_access: File name with path of the file in which the access data is written.</span>
<span class="sd">                </span>
<span class="sd">                The format of the output data file is as follows:</span>

<span class="sd">                *  The first row contains the coverage calculation type.</span>
<span class="sd">                *  The second row containing the mission epoch in Julian Day UT1. The time (index) in the state data is referenced to this epoch.</span>
<span class="sd">                *  The third row contains the time-step size in seconds. </span>
<span class="sd">                *  The fourth row contains the duration (in days) for which coverage calculation is executed.</span>
<span class="sd">                *  The fifth row contains the columns headers and the sixth row onwards contains the corresponding data. </span>

<span class="sd">                Note that time associated with a row is:  ``time = epoch (in JDUT1) + time-index * time-step-size (in secs) * (1/86400)`` </span>

<span class="sd">                Description of the coverage data is given below:</span>

<span class="sd">                .. csv-table:: Coverage data description</span>
<span class="sd">                    :header: Column, Data type, Units, Description</span>
<span class="sd">                    :widths: 10,10,10,30</span>

<span class="sd">                    time index, int, , Access time-index.</span>
<span class="sd">                    pnt-opt index, int, , &quot;Pointing options index. The indexing starts from 0, where 0 is the first pointing-option in the list of instrument pointing-options.&quot;</span>
<span class="sd">                    GP index, int, , Grid-point index.</span>
<span class="sd">                    lat [deg], float, degrees, Latitude corresponding to the GP index.</span>
<span class="sd">                    lon [deg], float, degrees, Longitude corresponding to the GP index.</span>
<span class="sd">        </span>
<span class="sd">        :paramtype out_file_access: str</span>

<span class="sd">        :param mid_access_only: Flag to indicate if the coverage data is to be processed to indicate only the access at the middle of an (continuous) access-interval. </span>
<span class="sd">                                Default value is ``False``.</span>
<span class="sd">        :paramtype mid_access_only: bool</span>

<span class="sd">        :param method:  Indicate the coverage method (relevant for the case of sensor FOVs described by spherical-polygon vertices and Rectangular FOV).</span>
<span class="sd">                        Only entries `DirectSphericalPIP` or `ProjectedPIP` or `RectangularPIP` are allowed. </span>
<span class="sd">                        Default method is `DirectSphericalPIP`.</span>

<span class="sd">                        The `DirectSphericalPIP` method corresponds to implementation of the `propcov.DSPIPCustomSensor` class, while</span>
<span class="sd">                        the `ProjectedPIP` corresponds to the implementation of the `propcov.GMATCustomSensor` class.                        </span>
<span class="sd">                        </span>
<span class="sd">                        For details on the `DirectSphericalPIP` method please refer to the article: R. Ketzner, V. Ravindra and M. Bramble, </span>
<span class="sd">                        &#39;A Robust, Fast, and Accurate Algorithm for Point in Spherical Polygon Classification with Applications in Geoscience and Remote Sensing&#39;, Computers and Geosciences, accepted.</span>
<span class="sd">                        </span>
<span class="sd">                        In the above article, the algorithm is described and compared to the GMAT CustomSensor algorithm which is the same as the </span>
<span class="sd">                        point-in-polygon algorithm implemented in the `propcov.GMATCustomSensor` class. </span>
<span class="sd">                        Compared to the `propcov.GMATCustomSensor` class, the `propcov.DSPIPCustomSensor` has been shown to yield improvement in runtime </span>
<span class="sd">                        and also to be more accurate.</span>

<span class="sd">                        `RectangularPIP` method is applicable only for RECTANGULAR spherical geometry shapes. It is based on the</span>
<span class="sd">                        `propcov.RectangularSensor` class. The class evaluates the dot product between the target point and the normal of the hemispherical-planes</span>
<span class="sd">                        formed by the 4 edges of the rectangle shape (on spherical surface). The corners of the rectangle are arranged in anti-clockwise manner about the center on the spherical surface,</span>
<span class="sd">                        if the target point is in the Northern hemisphere corresponding to 4 hemispherical planes formed by the edges of the rectangle, then the target falls</span>
<span class="sd">                        within the sensor FOV.</span>

<span class="sd">        :return: Coverage output info.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.CoverageOutputInfo`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###### read in the propagated states and auxillary information ######               </span>
        <span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="o">=</span> <span class="n">orbitpy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">extract_auxillary_info_from_state_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">)</span>
        <span class="n">states_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1">###### Prepare output file in which results shall be written ######</span>
        <span class="n">access_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file_access</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">access_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">access_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;POINTING OPTIONS WITH GRID COVERAGE&quot;</span><span class="p">])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Epoch [JDUT1] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Step size [s] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step_size</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Mission Duration [Days] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)])</span>
        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span><span class="s1">&#39;pnt-opt index&#39;</span><span class="p">,</span> <span class="s1">&#39;GP index&#39;</span><span class="p">,</span> <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>
        
        <span class="c1">###### find the coverage-parameters of the input sensor-id, mode-id  ######</span>
        <span class="n">cov_param</span><span class="o">=</span> <span class="n">find_in_cov_params_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">instru_id</span><span class="p">,</span> <span class="n">mode_id</span><span class="p">)</span>
        
        <span class="c1"># the input instru_id, mode_id may be None, so get the sensor, mode ids.</span>
        <span class="n">instru_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">instru_id</span>
        <span class="n">mode_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">mode_id</span>

        <span class="n">sen_sph_geom</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">scene_field_of_view</span><span class="o">.</span><span class="n">sph_geom</span> <span class="c1"># only the spherical geometry of the sensor is required. the orientation is ignored, since the pointing-option gives the orientation of the pointing-axis in the NADIR_POINTING frame.</span>
        <span class="n">pointing_option</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">pointing_option</span>
        <span class="k">if</span> <span class="n">pointing_option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No pointing options specified for the particular sensor, mode. Exiting PointingOptionsWithGridCoverage.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1">###### iterate and calculate coverage seperately for each pointing-option.</span>
        <span class="k">for</span> <span class="n">pnt_opt_idx</span><span class="p">,</span> <span class="n">pnt_opt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pointing_option</span><span class="p">):</span>
            
            <span class="c1">###### form the propcov.Spacecraft object ######</span>
            <span class="n">attitude</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">NadirPointingAttitude</span><span class="p">()</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">LagrangeInterpolator</span><span class="p">()</span>
            <span class="n">spc</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">orbitState</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">orbitState</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">attitude</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># align spacecraft to NADIR_POINTING frame</span>
          
            <span class="c1">###### build the sensor object ######</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">):</span>
                <span class="n">sensor</span><span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">ConicalSensor</span><span class="p">(</span><span class="n">halfAngle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">diameter</span><span class="p">))</span> <span class="c1"># input angle in radians</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span> <span class="ow">or</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;DirectSphericalPIP&quot;</span><span class="p">:</span>
                    <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">DSPIPCustomSensor</span><span class="p">(</span> <span class="n">coneAngleVecIn</span>    <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">cone_angle_vec</span>   <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>  <span class="c1"># input angle in radians  </span>
                                                <span class="n">clockAngleVecIn</span>   <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">clock_angle_vec</span>  <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>
                                                <span class="n">contained</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>  
                                                <span class="p">)</span>
                
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;ProjectedPIP&quot;</span><span class="p">:</span>
                    <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">GMATCustomSensor</span><span class="p">(</span> <span class="n">coneAngleVecIn</span>    <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">cone_angle_vec</span>   <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>  <span class="c1"># input angle in radians  </span>
                                                <span class="n">clockAngleVecIn</span>   <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">clock_angle_vec</span>  <span class="p">)</span>   <span class="p">)</span>   <span class="p">)</span>   
                                                <span class="p">)</span>
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;RectangularPIP&#39;</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">angleHeightIn</span><span class="p">,</span> <span class="n">angleWidthIn</span><span class="p">]</span> <span class="o">=</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">get_fov_height_and_width</span><span class="p">()</span>
                    <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">RectangularSensor</span><span class="p">(</span> <span class="n">angleHeightIn</span>    <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">angleHeightIn</span> <span class="p">)</span> <span class="p">,</span>  <span class="c1"># input angle in radians  </span>
                                                        <span class="n">angleWidthIn</span>   <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">angleWidthIn</span> <span class="p">)</span>   
                                                        <span class="p">)</span>        
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;please input valid sensor spherical geometry shape.&quot;</span><span class="p">)</span>
            <span class="c1"># orient sensor according to the pointing-option</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span><span class="p">):</span> 
                <span class="n">sensor</span><span class="o">.</span><span class="n">SetSensorBodyOffsetAngles</span><span class="p">(</span><span class="n">angle1</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span> <span class="c1"># input angles are in degrees</span>
                                                   <span class="n">seq1</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="n">seq3</span><span class="o">=</span><span class="n">pnt_opt</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            
            <span class="c1">###### attach the sensor ######</span>
            <span class="n">spc</span><span class="o">.</span><span class="n">AddSensor</span><span class="p">(</span><span class="n">sensor</span><span class="p">)</span>
            <span class="c1">###### make propcov coverage checker object ######</span>
            <span class="n">cov_checker</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">CoverageChecker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">point_group</span><span class="p">,</span> <span class="n">spc</span><span class="p">)</span>
            <span class="c1">###### iterate over the propagated states ######</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">AbsoluteDate</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">])</span>
                <span class="n">jd_date</span> <span class="o">=</span> <span class="n">epoch_JDUT1</span> <span class="o">+</span> <span class="n">time_index</span><span class="o">*</span><span class="n">step_size</span><span class="o">*</span><span class="n">DAYS_PER_SEC</span>
                <span class="n">date</span><span class="o">.</span><span class="n">SetJulianDate</span><span class="p">(</span><span class="n">jd_date</span><span class="p">)</span>
                
                <span class="n">cart_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;x [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;y [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;z [km]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vx [km/s]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vy [km/s]&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;vz [km/s]&#39;</span><span class="p">]]</span>
                <span class="n">spc</span><span class="o">.</span><span class="n">SetOrbitEpochOrbitStateCartesian</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector6</span><span class="p">(</span><span class="n">cart_state</span><span class="p">))</span>
                
                <span class="c1"># compute coverage</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">cov_checker</span><span class="o">.</span><span class="n">CheckPointCoverage</span><span class="p">()</span> <span class="c1"># list of indices of the GPs accessed shall be returned</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#If no ground-points are accessed at this time, skip writing the row altogether.</span>
                    <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get_lat_lon_from_index</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
                        <span class="n">access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">time_index</span><span class="p">,</span> <span class="n">pnt_opt_idx</span><span class="p">,</span> <span class="n">pnt</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="c1">##### Close file #####                </span>
        <span class="n">access_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1">##### filter mid-interval access data if necessary #####</span>
        <span class="k">if</span> <span class="n">mid_access_only</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#inp_acc_df = pd.read_csv(out_file_access, skiprows = 4)</span>
            <span class="n">filter_mid_interval_access</span><span class="p">(</span><span class="n">inp_acc_fl</span><span class="o">=</span><span class="n">out_file_access</span><span class="p">,</span> <span class="n">out_acc_fl</span><span class="o">=</span><span class="n">out_file_access</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CoverageOutputInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span>   <span class="s2">&quot;coverageType&quot;</span><span class="p">:</span> <span class="s2">&quot;POINTING OPTIONS WITH GRID COVERAGE&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;spacecraftId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraft</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span>
                                                <span class="s2">&quot;instruId&quot;</span><span class="p">:</span> <span class="n">instru_id</span><span class="p">,</span>
                                                <span class="s2">&quot;modeId&quot;</span><span class="p">:</span> <span class="n">mode_id</span><span class="p">,</span>
                                                <span class="s2">&quot;usedFieldOfRegard&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;filterMidIntervalAccess&quot;</span><span class="p">:</span> <span class="n">mid_access_only</span><span class="p">,</span>
                                                <span class="s2">&quot;gridId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span>
                                                <span class="s2">&quot;stateCartFile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                                                <span class="s2">&quot;accessFile&quot;</span><span class="p">:</span> <span class="n">out_file_access</span><span class="p">,</span>
                                                <span class="s2">&quot;startDate&quot;</span><span class="p">:</span> <span class="n">epoch_JDUT1</span><span class="p">,</span>
                                                <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
                                                <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span></div></div>

<div class="viewcode-block" id="SpecularCoverage"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage">[docs]</a><span class="k">class</span> <span class="nc">SpecularCoverage</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A coverage calculator which handles coverage calculation for a spacecraft with a reflectometer instrument. </span>
<span class="sd">        Coverage calculation involves calculation of specular point locations at each propagation time step. A grid can also be specified, and the </span>
<span class="sd">        coverage results shall include the set of grid-points within a predefined circular region about each specular point. </span>

<span class="sd">        The specifications and the state files of the receiver spacecraft and source spacecrafts (&gt;=1) are to be provided during the object instantiation.</span>
<span class="sd">        In the state files, the epoch, propagation time resolution, must be the same across all the spacecrafts (receiver and source).</span>

<span class="sd">        The specular locations within the sensor FOV is calculated at each time step.</span>
<span class="sd">        If a grid is specified, the set of grid-points within a specified circular region about each of the specular locations are also calculated.</span>

<span class="sd">        The transmitter spacecraft is assumed to transmit the RF signal over it&#39;s entire visible horizon.</span>

<span class="sd">    :ivar rx_spc: Spacecraft for which the coverage calculation is performed. An instrument may or may not be present on the spacecraft.</span>
<span class="sd">                  This spacecraft is also the receiver which processes the reflected RF signal.</span>
<span class="sd">    :vartype rx_spc: :class:`orbitpy.util.Spacecraft`</span>

<span class="sd">    :ivar rx_state_file: File name with path of the (input) file in which the orbit states of the receiving spacecraft in ``CARTESIAN_EARTH_CENTERED_INERTIAL`` frame are available.</span>
<span class="sd">                         Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the file data format.</span>
<span class="sd">    :vartype rx_state_file: str</span>

<span class="sd">    :ivar tx_spc: (List) Spacecrafts from which the RF signal originates (e.g. GNSS satellites).</span>
<span class="sd">    :vartype tx_spc: list, :class:`orbitpy.util.Spacecraft`</span>

<span class="sd">    :ivar tx_state_file: List of state files corresponding to the source spacecrafts. The order of entries *must* match with the order of entries of the ``src`` argument.</span>
<span class="sd">                          Each list entry is the file name with path of the (input) file in which the states in CARTESIAN_EARTH_CENTERED_INERTIAL frame are available.</span>
<span class="sd">                          Refer to :class:`orbitpy.propagator.J2AnalyticalPropagator.execute` for description of the file data format.</span>
<span class="sd">    :vartype tx_state_file: list, str</span>

<span class="sd">    :ivar grid: Locations (longitudes, latitudes) (represented by a :class:`orbitpy.util.grid` object) over which coverage calculation is to be performed.</span>
<span class="sd">                Required only if grid-based coverage is needed.</span>
<span class="sd">    :vartype grid: :class:`orbitpy.util.grid`</span>

<span class="sd">    :ivar cov_params: List of coverage parameters corresponding to all the instruments, modes per instrument in the spacecraft.</span>
<span class="sd">                        Refer to the :class:`orbitpy.coveragecalculator.helper_extract_coverage_parameters_of_spacecraft` function.</span>
<span class="sd">    :vartype cov_params: list, namedtuple</span>

<span class="sd">    :ivar _id: Unique identifier.</span>
<span class="sd">    :vartype _id: str</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpecularCoverage.__init__"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rx_spc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rx_state_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tx_spc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tx_state_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span>             <span class="o">=</span> <span class="n">rx_spc</span> <span class="k">if</span> <span class="n">rx_spc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rx_spc</span><span class="p">,</span> <span class="n">Spacecraft</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_state_file</span>      <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rx_state_file</span><span class="p">)</span> <span class="k">if</span> <span class="n">rx_state_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_spc</span>             <span class="o">=</span> <span class="n">orbitpy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">initialize_object_list</span><span class="p">(</span><span class="n">tx_spc</span><span class="p">,</span> <span class="n">Spacecraft</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tx_state_file</span>      <span class="o">=</span> <span class="n">orbitpy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">initialize_object_list</span><span class="p">(</span><span class="n">tx_state_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>               <span class="o">=</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Grid</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># Extract the coverage related parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span> <span class="o">=</span> <span class="n">helper_extract_coverage_parameters_of_spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SpecularCoverage</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="s2">&quot;SPECULAR COVERAGE&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpecularCoverage.from_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Parses an ``SpecularCoverage`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the SpecularCoverage specifications.</span>

<span class="sd">                Following keys are to be specified.                </span>
<span class="sd">                </span>
<span class="sd">                * &quot;receiver&quot;:                       (dict) Consists of two keys: </span>
<span class="sd">                                        </span>
<span class="sd">                                                            (1) &quot;spacecraft&quot;: (dict) Receiver spacecraft specifications. Refer to :class:`orbitpy.util.Spacecraft.from_dict`</span>

<span class="sd">                                                            (2) &quot;cartesianStateFilePath&quot;: (str) File path (with file name) to the file with the propagated (receiver) spacecraft states.</span>

<span class="sd">                 * &quot;source&quot;:                        (list, dict) List of sources. Each dictionary entry in the list consists of the following two keys:</span>

<span class="sd">                                                            (1) &quot;spacecraft&quot;: (dict) Source spacecraft specifications. Refer to :class:`orbitpy.util.Spacecraft.from_dict`</span>

<span class="sd">                                                            (2) &quot;cartesianStateFilePath&quot;: (str) File path (with file name) to the file with the propagated (source) spacecraft states.</span>

<span class="sd">                * &quot;grid&quot;:                           (dict) Required only if grid-based coverage is needed. Refer to :class:`orbitpy.grid.Grid.from_dict`</span>
<span class="sd">                </span>
<span class="sd">                * &quot;@id&quot;:                            (str or int) Unique identifier of the coverage calculator object.</span>

<span class="sd">                In the provided state files, the epoch, propagation time resolution, must be the same across all the spacecrafts (receiver and source).</span>

<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``SpecularCoverage`` object.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.SpecularCoverage`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># parse the reciever</span>
        <span class="n">receiver_dict</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;receiver&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">rx_spc_dict</span>     <span class="o">=</span> <span class="n">receiver_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spacecraft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">rx_spc</span>          <span class="o">=</span> <span class="n">Spacecraft</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">rx_spc_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">rx_spc_dict</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">rx_state_file</span>   <span class="o">=</span> <span class="n">receiver_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cartesianStateFilePath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># parse the source</span>
        <span class="n">source_dict</span>     <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># make into list if not list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">source_dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_dict</span><span class="p">]</span>

        <span class="n">tx_spc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tx_state_file</span> <span class="o">=</span>  <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">source_dict</span><span class="p">:</span>
            <span class="n">_spc_dict</span>     <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spacecraft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">_spc</span>          <span class="o">=</span> <span class="n">Spacecraft</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">_spc_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">_spc_dict</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">_state_file</span>   <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cartesianStateFilePath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_spc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_state_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tx_spc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_spc</span><span class="p">)</span>
                <span class="n">tx_state_file</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_state_file</span><span class="p">)</span>

        <span class="n">grid_dict</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SpecularCoverage</span><span class="p">(</span><span class="n">rx_spc</span>          <span class="o">=</span> <span class="n">rx_spc</span><span class="p">,</span>
                                <span class="n">rx_state_file</span>   <span class="o">=</span> <span class="n">rx_state_file</span><span class="p">,</span>
                                <span class="n">tx_spc</span>          <span class="o">=</span> <span class="n">tx_spc</span><span class="p">,</span>
                                <span class="n">tx_state_file</span>   <span class="o">=</span> <span class="n">tx_state_file</span><span class="p">,</span>
                                <span class="n">grid</span>            <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">grid_dict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                                <span class="n">_id</span>             <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;@id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="SpecularCoverage.to_dict"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the SpecularCoverage object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``SpecularCoverage`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># list of dictionaries containing the source spacecraft information (specifications, state file paths)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">spc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_spc</span><span class="p">):</span>
            <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">({</span> <span class="s2">&quot;spacecraft&quot;</span><span class="p">:</span> <span class="n">spc</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> 
                            <span class="s2">&quot;cartesianStateFilePath&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_state_file</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                          <span class="p">})</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;@type&quot;</span><span class="p">:</span> <span class="s2">&quot;SPECULAR COVERAGE&quot;</span><span class="p">,</span>                     
                     <span class="s2">&quot;receiver&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;spacecraft&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="s2">&quot;cartesianStateFilePath&quot;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_state_file</span><span class="p">},</span>
                     <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span>
                     <span class="s2">&quot;cartesianStateFilePath&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cart_file</span><span class="p">,</span>
                     <span class="s2">&quot;grid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SpecularCoverage.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

<div class="viewcode-block" id="SpecularCoverage.specular_location"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage.specular_location">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">specular_location</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  Find the location of the specular point given the position vectors of the source and receiving satellites.</span>
<span class="sd">             </span>
<span class="sd">             Reference: David Eberly, &quot;Computing a Point of Reflection on a Sphere&quot;, Geometric Tools, 2008. </span>
<span class="sd">             https://www.geometrictools.com/Documentation/SphereReflections.pdf</span>

<span class="sd">             Note that a unit sphere is considered in the reference. Hence the input position vectors of the satellites need to be scaled by 1/(radius of earth)</span>
<span class="sd">        </span>
<span class="sd">        :param S: Position vector of source (transmit) satellite.</span>
<span class="sd">        :paramtype S: list, float</span>

<span class="sd">        :param L: Position vector of receiving satellite.</span>
<span class="sd">        :paramtype L: list, float</span>

<span class="sd">        :return: Normalized Cartesian coordinates of the specular point if available, else ``False``.</span>
<span class="sd">        :rtype: list, float (or) bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RE</span> <span class="o">=</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span>
        <span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">RE</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">RE</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="c1"># check for line of sight condition between L and S. This is a necessary condition to be satisfied for existence of the specular point.</span>
        <span class="n">los</span> <span class="o">=</span> <span class="n">GeoUtilityFunctions</span><span class="o">.</span><span class="n">checkLOSavailability</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">los</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># check for special condition when vectors L, S are parallel. In this case the specular point is simply the intersection of L (or) S position vector with the sphere.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">N</span>
        
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>

        <span class="n">y4_coeff</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
        <span class="n">y3_coeff</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
        <span class="n">y2_coeff</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>
        <span class="n">y1_coeff</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span>
        <span class="n">y0_coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># compute the roots of the quartic equation</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">([</span><span class="n">y4_coeff</span><span class="p">,</span> <span class="n">y3_coeff</span><span class="p">,</span> <span class="n">y2_coeff</span><span class="p">,</span><span class="n">y1_coeff</span><span class="p">,</span> <span class="n">y0_coeff</span><span class="p">])</span>

        <span class="c1"># check for real valued roots y_bar</span>
        <span class="n">real_valued</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-5</span><span class="p">]</span> <span class="c1"># where 1e-5 is a threshold</span>
        <span class="c1">#print(&quot;real_valued &quot;, real_valued)</span>

        <span class="c1"># check for root y_bar&gt;0</span>
        <span class="n">x_bar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">y_bar</span> <span class="ow">in</span> <span class="n">real_valued</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y_bar</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">_x_bar</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">y_bar</span><span class="o">*</span><span class="n">y_bar</span> <span class="o">+</span> <span class="n">y_bar</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">y_bar</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># check for pair (x_bar, y_bar) so that x_bar&gt;0, y_bar&gt;0</span>
                <span class="k">if</span> <span class="n">_x_bar</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">x_bar</span> <span class="o">=</span> <span class="n">_x_bar</span>
                    <span class="k">break</span>

        <span class="c1">#print(&quot;(x_bar, y_bar)&quot;, x_bar, y_bar)</span>

        <span class="c1"># specular point N = x_bar S + y_bar L</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">x_bar</span> <span class="o">*</span> <span class="n">S</span> <span class="o">+</span> <span class="n">y_bar</span> <span class="o">*</span> <span class="n">L</span>        

        <span class="c1">######## DEBUG ########</span>
        <span class="c1">#specular_direction = N - L</span>
        <span class="c1">#specular_cone_angle = np.arccos(np.dot(specular_direction, -L)/ (np.linalg.norm(specular_direction) * np.linalg.norm(-L)))</span>
        <span class="c1">#print(&quot;specular_cone_angle&quot;, np.rad2deg(specular_cone_angle))</span>
        <span class="c1">################################</span>

        <span class="k">return</span> <span class="n">RE</span><span class="o">*</span><span class="n">N</span></div>

<div class="viewcode-block" id="SpecularCoverage.check_point_in_circle"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage.check_point_in_circle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_point_in_circle</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">diameter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Check if the input point belong inside a circle (on the Earth&#39;s surface) of the specified center, diameter.</span>
<span class="sd">            The diameter is the distance measured along a great circle on the Earth&#39;s surface.</span>

<span class="sd">        :param point: Geo coordinates of the points which need to be evaluated (lat [deg], lon [deg]).</span>
<span class="sd">        :paramtype point: list, (float, float)</span>

<span class="sd">        :param center: Geo coordinates of the center of the circle (lat [deg], lon [deg]).</span>
<span class="sd">        :paramtype center: list, (float, float)</span>

<span class="sd">        :param diameter: Diameter of the circle [km].</span>
<span class="sd">        :paramtype diameter: float</span>

<span class="sd">        :return: ``True`` if the point belongs inside the circle, else ``False``.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RE</span> <span class="o">=</span> <span class="n">Constants</span><span class="o">.</span><span class="n">radiusOfEarthInKM</span>

        <span class="n">phi_1</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lambda_1</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">phi_2</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lambda_2</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">delta_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lambda_2</span> <span class="o">-</span> <span class="n">lambda_1</span><span class="p">))</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="n">RE</span> <span class="o">*</span> <span class="n">delta_sigma</span> <span class="c1"># radius of Earth times the central-angle</span>

        <span class="c1"># check if distance is less than the radius = 0.5*diameter of the circle</span>
        <span class="k">if</span> <span class="n">dis</span><span class="o">&lt;</span><span class="mf">0.5</span><span class="o">*</span><span class="n">diameter</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="SpecularCoverage.execute"><a class="viewcode-back" href="../../generated/orbitpy.coveragecalculator.SpecularCoverage.html#orbitpy.coveragecalculator.SpecularCoverage.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instru_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_file_specular</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">specular_region_dia</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_file_grid_access</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;DirectSphericalPIP&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform coverage calculation involving calculation of specular point locations. </span>
<span class="sd">            The calculation is performed for a specific instrument and mode (in the receiver spacecraft).</span>
<span class="sd">            Note that the sceneFOV of an instrument (which may be the same as the instrument FOV) is used for coverage calculations.</span>
<span class="sd">            If no instrument present in spacecraft the entire horizon as seen by the receiving satellite is considered for the coverage calculations (however this does not work when grid based calculations are required, see the TODO below). </span>
<span class="sd">            </span>
<span class="sd">            The transmitter spacecraft is assumed to transmit the RF signal over it&#39;s entire visible horizon.</span>

<span class="sd">            Coverage is calculated for the period over which the receiver, source spacecraft propagated states are available. </span>
<span class="sd">            The time-resolution of the coverage calculation is the same as the time resolution at which the spacecraft states are available.</span>

<span class="sd">            If a grid has been specified (during the instantiation of the ``grid`` instance variable), and the diameter of the specular region has been specified (through the ``specular_region_dia`` input parameter),</span>
<span class="sd">            then the grid points which are present within the specular region are found and written in the file specified by the ``out_file_grid_access`` parameter. The specular region is </span>
<span class="sd">            approximated to be circular in shape with the calculated specular point as the center, and the diameter specified by the ``specular_region_dia`` input parameter.</span>

<span class="sd">            .. todo:: When grid is specified, the sensor **must** be present, else a `NotImplementedError` is thrown. Modify this behaviour so </span>
<span class="sd">                      that the coverage calculations with grid can be carried out considering the entire horizon to be within the satellite FOV.</span>

<span class="sd">        :param instru_id: Sensor identifier (corresponding to the receiver spacecraft). If ``None``, the first sensor in the spacecraft list of sensors (if available) is considered.</span>
<span class="sd">        :paramtype instru_id: str (or) int</span>

<span class="sd">        :param mode_id: Mode identifier (corresponding to the receiver sensor (id) and spacecraft). If ``None``, the first mode of the corresponding input sensor of the spacecraft is considered.</span>
<span class="sd">        :paramtype mode_id: str (or) int</span>

<span class="sd">        :param out_file_specular: File name with path of the file in which the specular locaion data is to be written.</span>
<span class="sd">                </span>
<span class="sd">                The format of the output data file is as follows:</span>

<span class="sd">                *  The first row contains the coverage calculation type.</span>
<span class="sd">                *  The second row containing the mission epoch in Julian Day UT1. The time (index) in the state data is referenced to this epoch.</span>
<span class="sd">                *  The third row contains the time-step size in seconds.</span>
<span class="sd">                *  The fourth row contains the duration (in days) for which coverage calculation is executed.</span>
<span class="sd">                *  The fifth row contains the columns headers and the sixth row onwards contains the corresponding data. </span>

<span class="sd">                Note that time associated with a row is: ``time = epoch (in JDUT1) + time-index * time-step-size (in secs) * (1/86400)`` </span>

<span class="sd">                Description of the coverage data is given below:</span>

<span class="sd">                .. csv-table:: Coverage data description</span>
<span class="sd">                    :header: Column, Data type, Units, Description</span>
<span class="sd">                    :widths: 10,10,10,30</span>

<span class="sd">                    time index, int, , Access time-index.</span>
<span class="sd">                    source id, int/str, , Source spacecraft identifier.</span>
<span class="sd">                    lat [deg], float, degrees, Latitude of specular point.</span>
<span class="sd">                    lon [deg], float, degrees, Longitude of specular point.</span>
<span class="sd">        </span>
<span class="sd">        :paramtype out_file_specular: str</span>

<span class="sd">        :param specular_region_dia: Diameter of the circular region with the specular point as the center, which shall be imaged. </span>
<span class="sd">                                    Note that this is an approximation since the the specular region shape and dimensions </span>
<span class="sd">                                    shall depend on the source, receiver positions, topography, etc. Units in kilometers.</span>
<span class="sd">        :paramtype specular_region_dia: float</span>
<span class="sd">        </span>
<span class="sd">        :param out_file_grid_access: File name with path of the file in which the grid access data is written. This parameter should be input in the case when</span>
<span class="sd">                                        ``grid`` instance variable and the ``specular_region_dia`` input parameter are specified.</span>
<span class="sd">                </span>
<span class="sd">                The file format is as follows:</span>

<span class="sd">                *  The first row contains the coverage calculation type.</span>
<span class="sd">                *  The second row containing the mission epoch in Julian Day UT1. The time (index) in the state data is referenced to this epoch.</span>
<span class="sd">                *  The third row contains the time-step size in seconds. </span>
<span class="sd">                *  The fourth row contains the duration (in days) for which coverage calculation is executed.</span>
<span class="sd">                *  The fifth row contains the columns headers and the sixth row onwards contains the corresponding data. </span>

<span class="sd">                Note that time associated with a row is:  ``time = epoch (in JDUT1) + time-index * time-step-size (in secs) * (1/86400)`` </span>

<span class="sd">                Description of the coverage data is given below:</span>

<span class="sd">                .. csv-table:: Coverage data description</span>
<span class="sd">                    :header: Column, Data type, Units, Description</span>
<span class="sd">                    :widths: 10,10,10,30</span>

<span class="sd">                    time index, int, , Access time-index.                    </span>
<span class="sd">                    source id, int/str, , Source spacecraft identifier.</span>
<span class="sd">                    GP index, int, , Grid-point index.</span>
<span class="sd">                    lat [deg], float, degrees, Latitude corresponding to the GP index.</span>
<span class="sd">                    lon [deg], float, degrees, Longitude corresponding to the GP index.</span>

<span class="sd">        :paramtype out_file_grid_access: str</span>

<span class="sd">        :param method:  Indicate the coverage method to be used to evaluate if a specular location is within the sensor FOV or not. Additionally the same method is used to evaluate grid-based coverage.</span>
<span class="sd">                        This is only relevant for the case of sensor FOVs described by spherical-polygon vertices and including Rectangular FOV.</span>
<span class="sd">                        Only entries `DirectSphericalPIP` or `ProjectedPIP` or `RectangularPIP` are allowed. </span>
<span class="sd">                        Default method is `DirectSphericalPIP`.</span>

<span class="sd">                        The `DirectSphericalPIP` method corresponds to implementation of the `propcov.DSPIPCustomSensor` class, while</span>
<span class="sd">                        the `ProjectedPIP` corresponds to the implementation of the `propcov.GMATCustomSensor` class.                        </span>
<span class="sd">                        </span>
<span class="sd">                        For details on the `DirectSphericalPIP` method please refer to the article: R. Ketzner, V. Ravindra and M. Bramble, </span>
<span class="sd">                        &#39;A Robust, Fast, and Accurate Algorithm for Point in Spherical Polygon Classification with Applications in Geoscience and Remote Sensing&#39;, Computers and Geosciences, acccepted.</span>
<span class="sd">                        </span>
<span class="sd">                        In the above article, the algorithm is described and compared to the GMAT CustomSensor algorithm which is the same as the </span>
<span class="sd">                        point-in-polygon algorithm implemented in the `propcov.GMATCustomSensor` class. </span>
<span class="sd">                        Compared to the `propcov.GMATCustomSensor` class, the `propcov.DSPIPCustomSensor` has been shown to yield improvement in runtime </span>
<span class="sd">                        and also to be more accurate.</span>

<span class="sd">                        `RectangularPIP` method is applicable only for RECTANGULAR spherical geometry shapes. It is based on the</span>
<span class="sd">                        `propcov.RectangularSensor` class. The class evaluates the dot product between the target point and the normal of the hemispherical-planes</span>
<span class="sd">                        formed by the 4 edges of the rectangle shape (on spherical surface). The corners of the rectangle are arranged in anti-clockwise manner about the center on the spherical surface,</span>
<span class="sd">                        if the target point is in the Northern hemisphere corresponding to 4 hemispherical planes formed by the edges of the rectangle, then the target falls</span>
<span class="sd">                        within the sensor FOV.  </span>
<span class="sd"> </span>
<span class="sd">        :paramtype method: str</span>

<span class="sd">        :return: Coverage output info.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.CoverageOutputInfo`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">calc_grid_access</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">specular_region_dia</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out_file_grid_access</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">calc_grid_access</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">###### read in the receiver satellite propagated states and auxillary information ######               </span>
        <span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="o">=</span> <span class="n">orbitpy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">extract_auxillary_info_from_state_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_state_file</span><span class="p">)</span>
        <span class="n">rx_states_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_state_file</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1">###### Prepare output files in which results shall be written ######        </span>
        <span class="n">specular_access_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file_specular</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">specular_access_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">specular_access_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>
        <span class="n">specular_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;SPECULAR COVERAGE&quot;</span><span class="p">])</span>
        <span class="n">specular_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Epoch [JDUT1] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">)])</span>
        <span class="n">specular_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Step size [s] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step_size</span><span class="p">)])</span>
        <span class="n">specular_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Mission Duration [Days] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)])</span>
        <span class="n">specular_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span> <span class="s1">&#39;source id&#39;</span><span class="p">,</span> <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">out_file_grid_access</span><span class="p">:</span>
            <span class="n">grid_access_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file_grid_access</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">grid_access_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">grid_access_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>
            <span class="n">grid_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;SPECULAR COVERAGE GRID ACCESS&quot;</span><span class="p">])</span>
            <span class="n">grid_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Epoch [JDUT1] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch_JDUT1</span><span class="p">)])</span>
            <span class="n">grid_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Step size [s] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step_size</span><span class="p">)])</span>
            <span class="n">grid_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;Mission Duration [Days] is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)])</span>
            <span class="n">grid_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;time index&#39;</span><span class="p">,</span> <span class="s1">&#39;source id&#39;</span><span class="p">,</span> <span class="s1">&#39;GP index&#39;</span><span class="p">,</span> <span class="s1">&#39;lat [deg]&#39;</span><span class="p">,</span> <span class="s1">&#39;lon [deg]&#39;</span><span class="p">])</span>
            
        <span class="c1">###### build the sensor, spacecraft and the coverage-checker objects ######</span>
        <span class="n">cov_param</span><span class="o">=</span> <span class="n">find_in_cov_params_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">instru_id</span><span class="p">,</span> <span class="n">mode_id</span><span class="p">)</span>
        <span class="c1">#print(&quot;cov_param &quot;, cov_param)</span>
        <span class="c1"># the input instru_id, mode_id may be None, so get the sensor, mode ids.</span>
        <span class="n">instru_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">instru_id</span>
        <span class="n">mode_id</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">mode_id</span>
        <span class="n">view_geom</span> <span class="o">=</span> <span class="n">cov_param</span><span class="o">.</span><span class="n">scene_field_of_view</span>

        <span class="c1">###### form the propcov.Spacecraft object ######</span>
        <span class="n">attitude</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">NadirPointingAttitude</span><span class="p">()</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">LagrangeInterpolator</span><span class="p">()</span>

        <span class="n">spc</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Spacecraft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span><span class="o">.</span><span class="n">orbitState</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span><span class="o">.</span><span class="n">orbitState</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">attitude</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># orient the spacecraft-bus</span>
        <span class="n">spc_orien</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span><span class="o">.</span><span class="n">spacecraftBus</span><span class="o">.</span><span class="n">orientation</span>
        <span class="k">if</span> <span class="n">spc_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span><span class="p">:</span>            
            <span class="n">spc</span><span class="o">.</span><span class="n">SetBodyNadirOffsetAngles</span><span class="p">(</span><span class="n">angle1</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span> <span class="c1"># input angles are in degrees</span>
                                        <span class="n">seq1</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="n">seq3</span><span class="o">=</span><span class="n">spc_orien</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="c1"># only NADIR_POINTING reference frame is supported.           </span>

        <span class="c1">###### build the sensor object ######</span>
        <span class="n">sen_sph_geom</span> <span class="o">=</span> <span class="n">view_geom</span><span class="o">.</span><span class="n">sph_geom</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CIRCULAR</span><span class="p">):</span>
            <span class="n">sensor</span><span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">ConicalSensor</span><span class="p">(</span><span class="n">halfAngle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">diameter</span><span class="p">))</span> <span class="c1"># input angle in radians</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">RECTANGULAR</span> <span class="ow">or</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">SphericalGeometry</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;DirectSphericalPIP&#39;</span><span class="p">:</span>
                <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">DSPIPCustomSensor</span><span class="p">(</span> <span class="n">coneAngleVecIn</span>    <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">cone_angle_vec</span>   <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>  <span class="c1"># input angle in radians  </span>
                                            <span class="n">clockAngleVecIn</span>   <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">clock_angle_vec</span>  <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>
                                            <span class="n">contained</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>  
                                            <span class="p">)</span>
            
            <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;ProjectedPIP&#39;</span><span class="p">:</span>
                <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">GMATCustomSensor</span><span class="p">(</span> <span class="n">coneAngleVecIn</span>    <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">cone_angle_vec</span>   <span class="p">)</span>   <span class="p">)</span>   <span class="p">),</span>  <span class="c1"># input angle in radians  </span>
                                            <span class="n">clockAngleVecIn</span>   <span class="o">=</span>   <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">clock_angle_vec</span>  <span class="p">)</span>   <span class="p">)</span>   <span class="p">)</span>   
                                            <span class="p">)</span>
            <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;RectangularPIP&#39;</span><span class="p">:</span>
                <span class="p">[</span><span class="n">angleHeightIn</span><span class="p">,</span> <span class="n">angleWidthIn</span><span class="p">]</span> <span class="o">=</span> <span class="n">sen_sph_geom</span><span class="o">.</span><span class="n">get_fov_height_and_width</span><span class="p">()</span>
                <span class="n">sensor</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">RectangularSensor</span><span class="p">(</span> <span class="n">angleHeightIn</span>    <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">angleHeightIn</span> <span class="p">)</span> <span class="p">,</span>  <span class="c1"># input angle in radians  </span>
                                                    <span class="n">angleWidthIn</span>   <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span> <span class="n">angleWidthIn</span> <span class="p">)</span>   
                                                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please specify a valid coverage method.&quot;</span><span class="p">)</span>         
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Please input valid sensor spherical geometry shape.&quot;</span><span class="p">)</span>

        <span class="n">sen_orien</span> <span class="o">=</span> <span class="n">view_geom</span><span class="o">.</span><span class="n">orien</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">SC_BODY_FIXED</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span> <span class="ow">and</span> <span class="n">spc_orien</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">==</span> <span class="n">ReferenceFrame</span><span class="o">.</span><span class="n">NADIR_POINTING</span><span class="p">):</span> <span class="c1"># The second condition is equivalent of orienting sensor w.r.t spacecraft body when the spacecraft body is aligned to nadir-frame</span>
            <span class="n">sensor</span><span class="o">.</span><span class="n">SetSensorBodyOffsetAngles</span><span class="p">(</span><span class="n">angle1</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_angle3</span><span class="p">,</span> <span class="c1"># input angles are in degrees</span>
                                                <span class="n">seq1</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_seq2</span><span class="p">,</span> <span class="n">seq3</span><span class="o">=</span><span class="n">sen_orien</span><span class="o">.</span><span class="n">euler_seq3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
       
        <span class="c1">###### attach the sensor ######</span>
        <span class="n">spc</span><span class="o">.</span><span class="n">AddSensor</span><span class="p">(</span><span class="n">sensor</span><span class="p">)</span>
        <span class="c1">###### make propcov coverage checker object if grid-based access calculation is required. ######</span>
        <span class="k">if</span> <span class="n">calc_grid_access</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>                           
            <span class="n">cov_checker</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">CoverageChecker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">point_group</span><span class="p">,</span> <span class="n">spc</span><span class="p">)</span>
        
        <span class="c1">###### iterate over the each of the source satellites ######</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_spc</span><span class="p">):</span>
            
            <span class="n">tx_id</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">_id</span> <span class="c1"># source spacecraft id</span>
            <span class="n">tx_states_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx_state_file</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># read in the states</span>

            <span class="c1">###### make the data object ######</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">AbsoluteDate</span><span class="p">()</span>           

            <span class="c1">###### iterate over the propagated states ######</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rx_state</span> <span class="ow">in</span> <span class="n">rx_states_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

                <span class="n">specular_access_exists</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># flag to indicate if the specular location is present within the sensor FOV</span>

                <span class="n">time_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;time index&#39;</span><span class="p">])</span>
                <span class="n">jd_date</span> <span class="o">=</span> <span class="n">epoch_JDUT1</span> <span class="o">+</span> <span class="n">time_index</span><span class="o">*</span><span class="n">step_size</span><span class="o">*</span><span class="n">DAYS_PER_SEC</span>
                <span class="n">date</span><span class="o">.</span><span class="n">SetJulianDate</span><span class="p">(</span><span class="n">jd_date</span><span class="p">)</span>
                
                <span class="n">rx_cart_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;x [km]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;y [km]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;z [km]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;vx [km/s]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;vy [km/s]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;vz [km/s]&#39;</span><span class="p">]]</span>
                <span class="n">spc</span><span class="o">.</span><span class="n">SetOrbitEpochOrbitStateCartesian</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">propcov</span><span class="o">.</span><span class="n">Rvector6</span><span class="p">(</span><span class="n">rx_cart_state</span><span class="p">))</span>
                <span class="n">rx_pos_vec</span><span class="o">=</span> <span class="p">[</span><span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;x [km]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;y [km]&#39;</span><span class="p">],</span> <span class="n">rx_state</span><span class="p">[</span><span class="s1">&#39;z [km]&#39;</span><span class="p">]]</span>

                <span class="n">tx_state</span> <span class="o">=</span> <span class="n">tx_states_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">tx_pos_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">tx_state</span><span class="p">[</span><span class="s1">&#39;x [km]&#39;</span><span class="p">],</span> <span class="n">tx_state</span><span class="p">[</span><span class="s1">&#39;y [km]&#39;</span><span class="p">],</span> <span class="n">tx_state</span><span class="p">[</span><span class="s1">&#39;z [km]&#39;</span><span class="p">]]</span>

                <span class="c1"># calculate the specular location within the entire horizon (if present)</span>
                <span class="n">specular_point</span><span class="o">=</span> <span class="n">SpecularCoverage</span><span class="o">.</span><span class="n">specular_location</span><span class="p">(</span><span class="n">tx_pos_vec</span><span class="p">,</span> <span class="n">rx_pos_vec</span><span class="p">)</span> <span class="c1"># result shall be in ECI Cartesian coordinates since input vectors are expressed in the ECI frame</span>
                <span class="c1"># evaluate if this specular point is within the sensor FOV</span>
                <span class="k">if</span> <span class="n">specular_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">sp_geocoods</span> <span class="o">=</span> <span class="n">GeoUtilityFunctions</span><span class="o">.</span><span class="n">eci2geo</span><span class="p">(</span><span class="n">specular_point</span><span class="p">,</span> <span class="n">jd_date</span><span class="p">)</span> <span class="c1"># (lat, lon) of the specular point</span>
                    <span class="c1">#print(&quot;sp_geocoods&quot;, sp_geocoods)</span>

                    <span class="n">sp_lat_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">sp_geocoods</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">sp_lon_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">sp_geocoods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">sp_lon_rad</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                        <span class="n">sp_lon_rad</span> <span class="o">=</span> <span class="n">sp_lon_rad</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="c1"># bring to the -pi to +pi range (requirement for the PointGroup class).</span>

                    <span class="n">sp_point_group</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">PointGroup</span><span class="p">()</span> <span class="c1"># create a point group which holds only the specular point</span>
                    <span class="n">sp_point_group</span><span class="o">.</span><span class="n">AddUserDefinedPoints</span><span class="p">([</span><span class="n">sp_lat_rad</span><span class="p">],[</span><span class="n">sp_lon_rad</span><span class="p">])</span>
                    <span class="c1"># make the coverage checker object</span>
                    <span class="n">sp_cov_checker</span> <span class="o">=</span> <span class="n">propcov</span><span class="o">.</span><span class="n">CoverageChecker</span><span class="p">(</span><span class="n">sp_point_group</span><span class="p">,</span> <span class="n">spc</span><span class="p">)</span>
                    <span class="c1"># check coverage</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">sp_cov_checker</span><span class="o">.</span><span class="n">CheckPointCoverage</span><span class="p">()</span>
                    <span class="c1">#print(&quot;x&quot;, x)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># the specular point is within the sensor FOV</span>
                        <span class="n">specular_access_exists</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1">#print(&quot;specular_access_exists&quot;, specular_access_exists)</span>
                <span class="k">if</span> <span class="n">specular_access_exists</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>                    
                    <span class="c1">###### write the specular location to the file ######</span>
                    <span class="n">specular_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">time_index</span><span class="p">,</span> <span class="n">tx_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sp_geocoods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sp_geocoods</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">)])</span>

                    <span class="c1">###### if applicable, carry out grid-based coverage ######</span>
                    <span class="k">if</span> <span class="n">calc_grid_access</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1"># compute coverage over the assigned grid</span>
                        <span class="n">points</span> <span class="o">=</span> <span class="n">cov_checker</span><span class="o">.</span><span class="n">CheckPointCoverage</span><span class="p">()</span> <span class="c1"># list of indices of the GPs accessed shall be returned</span>
                        <span class="n">filtered_points_index</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of filtered (within the specular region) points in geo-coordinates</span>
                        <span class="n">filtered_points_geo</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>                            
                            <span class="k">for</span> <span class="n">_pnt</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                                <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get_lat_lon_from_index</span><span class="p">(</span><span class="n">_pnt</span><span class="p">)</span>
                                <span class="n">coords_lat_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
                                <span class="n">coords_lon_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
                                
                                <span class="k">if</span> <span class="n">SpecularCoverage</span><span class="o">.</span><span class="n">check_point_in_circle</span><span class="p">([</span><span class="n">coords_lat_rad</span><span class="p">,</span> <span class="n">coords_lon_rad</span><span class="p">],</span> <span class="p">[</span><span class="n">sp_lat_rad</span><span class="p">,</span> <span class="n">sp_lon_rad</span><span class="p">],</span> <span class="n">specular_region_dia</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># check if the point lies within the circular perimeter around the specular location</span>
                                    <span class="n">filtered_points_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pnt</span><span class="p">)</span>
                                    <span class="n">filtered_points_geo</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">coords</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">longitude</span><span class="p">])</span>

                        <span class="c1"># Write the grid-points to the output file                   </span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_points_index</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filtered_points_geo</span><span class="p">):</span>
                                <span class="n">lat</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">lon</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">gp_index</span> <span class="o">=</span> <span class="n">filtered_points_index</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                                <span class="n">grid_access_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">time_index</span><span class="p">,</span> <span class="n">tx_id</span><span class="p">,</span> <span class="n">gp_index</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>                        

        <span class="c1">##### Close file ##### </span>
        <span class="k">try</span><span class="p">:</span>               
            <span class="n">specular_access_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grid_access_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">CoverageOutputInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span>   <span class="s2">&quot;coverageType&quot;</span><span class="p">:</span> <span class="s2">&quot;SPECULAR COVERAGE&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;spacecraftId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_spc</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span>
                                                <span class="s2">&quot;instruId&quot;</span><span class="p">:</span> <span class="n">instru_id</span><span class="p">,</span>
                                                <span class="s2">&quot;modeId&quot;</span><span class="p">:</span> <span class="n">mode_id</span><span class="p">,</span>
                                                <span class="s2">&quot;usedFieldOfRegard&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;filterMidIntervalAccess&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;gridId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_id</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;stateCartFile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_state_file</span><span class="p">,</span>
                                                <span class="s2">&quot;accessFile&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">out_file_specular</span><span class="p">,</span> <span class="n">out_file_grid_access</span><span class="p">],</span>
                                                <span class="s2">&quot;startDate&quot;</span><span class="p">:</span> <span class="n">epoch_JDUT1</span><span class="p">,</span>
                                                <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
                                                <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>    </div></div>
    

<span class="k">class</span> <span class="nc">CoverageOutputInfo</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class to hold information about the results of the coverage calculation. An object of this class is returned upon the execution</span>
<span class="sd">        of the coverage calculator.</span>
<span class="sd">    </span>
<span class="sd">    :ivar coverageType: Type of coverage calculator which produced the results.</span>
<span class="sd">    :vartype coverageType: str</span>

<span class="sd">    :ivar spacecraftId: Spacecraft identifier.</span>
<span class="sd">    :vartype spacecraftId: str or int</span>

<span class="sd">    :param instruId: Sensor identifier.</span>
<span class="sd">    :paramtype instruId: str (or) int</span>

<span class="sd">    :param modeId: Mode identifier.</span>
<span class="sd">    :paramtype modeId: str (or) int </span>

<span class="sd">    :param usedFieldOfRegard: Boolean flag which indicates if the field-of-regard was used in the coverage calculations. </span>
<span class="sd">                              If not relevant the value is ``None``. </span>
<span class="sd">    :paramtype usedFieldOfRegard: bool (or) None</span>

<span class="sd">    :param filterMidIntervalAccess: Flag to indicate if the coverage data is to be processed to indicate only the access at the middle of an (continuous) access-interval. </span>
<span class="sd">                                       If not relevant (such as in the case of pointing-options coverage) the value is ``None``. </span>
<span class="sd">    :paramtype filterMidIntervalAccess: bool (or) None</span>

<span class="sd">    :param gridId: Grid identifier. </span>
<span class="sd">    :paramtype gridId: str (or) int </span>

<span class="sd">    :ivar stateCartFile: State file (filename with path) where the time-series of the cartesian states of the spacecraft are saved.</span>
<span class="sd">    :vartype stateCartFile: str</span>

<span class="sd">    :ivar accessFile: File (filename with path) where the access data is saved. Multiple files can be indicated by a list.</span>
<span class="sd">    :vartype accessFile: str (or) list, str</span>

<span class="sd">    :ivar startDate: Time start for coverage calculation in Julian Date UT1.</span>
<span class="sd">    :vartype startDate: float</span>

<span class="sd">    :ivar duration: Time duration over which coverage was calculated in days.</span>
<span class="sd">    :vartype duration: float</span>

<span class="sd">    :ivar _id: Unique identifier.</span>
<span class="sd">    :vartype _id: str or int</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coverageType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacecraftId</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instruId</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modeId</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usedFieldOfRegard</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filterMidIntervalAccess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">gridId</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">stateCartFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">accessFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">startDate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coverageType</span> <span class="o">=</span> <span class="n">coverageType</span> <span class="k">if</span> <span class="n">coverageType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacecraftId</span> <span class="o">=</span> <span class="n">spacecraftId</span> <span class="k">if</span> <span class="n">spacecraftId</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instruId</span> <span class="o">=</span> <span class="n">instruId</span> <span class="k">if</span> <span class="n">instruId</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modeId</span> <span class="o">=</span> <span class="n">modeId</span> <span class="k">if</span> <span class="n">modeId</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridId</span> <span class="o">=</span> <span class="n">gridId</span> <span class="k">if</span> <span class="n">gridId</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">usedFieldOfRegard</span> <span class="o">=</span> <span class="n">usedFieldOfRegard</span> <span class="k">if</span> <span class="n">usedFieldOfRegard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterMidIntervalAccess</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">filterMidIntervalAccess</span><span class="p">)</span> <span class="k">if</span> <span class="n">filterMidIntervalAccess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stateCartFile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stateCartFile</span><span class="p">)</span> <span class="k">if</span> <span class="n">stateCartFile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">accessFile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">accessFile</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">accessFile</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">accessFile</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">accessFile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">accessFile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startDate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">startDate</span><span class="p">)</span> <span class="k">if</span> <span class="n">startDate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="k">if</span> <span class="n">duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CoverageOutputInfo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="n">OutputInfoUtility</span><span class="o">.</span><span class="n">OutputInfoType</span><span class="o">.</span><span class="n">CoverageOutputInfo</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Parses an ``CoverageOutputInfo`` object from a normalized JSON dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :param d: Dictionary with the CoverageOutputInfo attributes.</span>
<span class="sd">        :paramtype d: dict</span>

<span class="sd">        :return: ``CoverageOutputInfo`` object.</span>
<span class="sd">        :rtype: :class:`orbitpy.coveragecalculator.CoverageOutputInfo`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CoverageOutputInfo</span><span class="p">(</span> <span class="n">coverageType</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coverageType&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">spacecraftId</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spacecraftId&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">instruId</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;instruId&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">modeId</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;modeId&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">usedFieldOfRegard</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;usedFieldOfRegard&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">filterMidIntervalAccess</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;filterMidIntervalAccess&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">gridId</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gridId&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">stateCartFile</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stateCartFile&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">accessFile</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;accessFile&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">startDate</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;startDate&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">duration</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;duration&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">_id</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;@id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translate the CoverageOutputInfo object to a Python dictionary such that it can be uniquely reconstructed back from the dictionary.</span>
<span class="sd">        </span>
<span class="sd">        :return: ``CoverageOutputInfo`` object as python dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;@type&quot;</span><span class="p">:</span> <span class="n">OutputInfoUtility</span><span class="o">.</span><span class="n">OutputInfoType</span><span class="o">.</span><span class="n">CoverageOutputInfo</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                     <span class="s2">&quot;coverageType&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverageType</span><span class="p">,</span>
                     <span class="s2">&quot;spacecraftId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacecraftId</span><span class="p">,</span>
                     <span class="s2">&quot;instruId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">instruId</span><span class="p">,</span>
                     <span class="s2">&quot;modeId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modeId</span><span class="p">,</span>
                     <span class="s2">&quot;usedFieldOfRegard&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">usedFieldOfRegard</span><span class="p">,</span>
                     <span class="s2">&quot;filterMidIntervalAccess&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filterMidIntervalAccess</span><span class="p">,</span>
                     <span class="s2">&quot;gridId&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridId</span><span class="p">,</span>
                     <span class="s2">&quot;stateCartFile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateCartFile</span><span class="p">,</span>
                     <span class="s2">&quot;accessFile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">accessFile</span><span class="p">,</span>
                     <span class="s2">&quot;startDate&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">startDate</span><span class="p">,</span>
                     <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
                     <span class="s2">&quot;@id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">})</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;CoverageOutputInfo.from_dict(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Equality test is simple one which compares the data attributes. Note that _id data attribute may be different.</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="c1"># Note that the ``accessFile`` instance variable is a list in general, and a True comparison result requires the same ordering of the elements of the two input lists (which are being compared). </span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coverageType</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">coverageType</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraftId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">spacecraftId</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instruId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">instruId</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modeId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">modeId</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usedFieldOfRegard</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">usedFieldOfRegard</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filterMidIntervalAccess</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">filterMidIntervalAccess</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">gridId</span><span class="p">)</span> <span class="ow">and</span>  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateCartFile</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">stateCartFile</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accessFile</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">accessFile</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">startDate</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">startDate</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span> 
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    
    <span class="k">def</span> <span class="nf">check_loose_equality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Check for equality with another ``CoverageOutputInfo`` object considering only some instance variables.</span>

<span class="sd">            :param other: The other ``CoverageOutputInfo`` object with which the comparision shall be done.</span>
<span class="sd">            :paramtype other: :class:`orbitpy.coveragecalculator.CoverageOutputInfo`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coverageType</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">coverageType</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacecraftId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">spacecraftId</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instruId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">instruId</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modeId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">modeId</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usedFieldOfRegard</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">usedFieldOfRegard</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filterMidIntervalAccess</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">filterMidIntervalAccess</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridId</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">gridId</span><span class="p">)</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, BAERI.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>